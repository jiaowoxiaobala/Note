1. [Before You memo()](https://overreacted.io/before-you-memo/)

>文章讲的是在使用`useMemo`和`memo`做优化前，可以**从不变的部分中分割出变化的部分**来代替`memo`。


- 向下移动`state`

```ts
import { useState } from 'react';

// 这是一个具有渲染性能的组件，当color改变时，ExpensiveTree组件也会重新渲染
export default function App() {
  const [color, setColor] = useState('red');
  return (
    <div>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
      <ExpensiveTree />
    </div>
  );
}

function ExpensiveTree() {
  let now = performance.now();
  while (performance.now() - now < 100) {
    // Artificial delay -- do nothing for 100ms
  }
  return <p>I am a very slow component tree.</p>;
}

// fix
export default function App() {
  return (
    <>
      <Form />
      <ExpensiveTree />
    </>
  );
}

function Form() {
  const [color, setColor] = useState('red');
  return (
    <>
      // 把真正关心color状态的部分提取到Form组件中，然后将状态移到该组件
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
    </>
  );
}
```

- 内容提升

```ts
export default function App() {
  const [color, setColor] = useState('red');
  return (
    // 如果将color绑定到父元素div中，向下移动状态就无法奏效
    <div style={{ color }}>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p>Hello, world!</p>
      <ExpensiveTree />
    </div>
  );
}

// fix
export default function App() {
  return (
    // 将不关心color的部分依然放到APP组件中，然后以JSX内容的形式传递给ColorPicker
    // 当color变化时，ColorPicker会重新渲染，但它仍然保留着上一次从APP中拿到相同的Children属性
    <ColorPicker>
      <p>Hello, world!</p>
      <ExpensiveTree />
    </ColorPicker>
  );
}

// 依赖color的代码就和color state变量一起放入ColorPicker组件里
function ColorPicker({ children }) {
  const [color, setColor] = useState("red");
  return (
    <div style={{ color }}>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      {children}
    </div>
  );
}
```


2. [A Complete Guide to useEffect](https://overreacted.io/a-complete-guide-to-useeffect/)

收集中...