## 实现一个LRU算法

>`Least Recently Used`最近最少使用，算法根据数据的历史记录来进行淘汰数据，其核心思想“如果数据最近被访问过，那么将来被访问的几率也更高”。

- 利用`Map`来做数据的存储，并给定一个最大存储容量。

- 读取/设置时，如果数据原本存在，先删掉，再重新添加进去（保证数据是最新添加的

- 设置后，如果超出了最大容量，利用`Map`原型上的`key`方法获取到最早插入元素的`key`值进行删除

```js
class LRUCache {
  cache = new Map();
  constructor(max) {
    this.max = max
  }

  put(key, val) {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    }
    this.cache.set(key, val)

    if (this.cache.size > this.max) {
      // Map原型上的keys方法会返回一个引用的迭代器对象，包含按顺序插入的每个元素的key值
      const delKey = this.cache.keys().next().value
      this.cache.delete(delKey)
    }
  }

  get(key)  {
    if (this.cache.has(key)) {
      const val = this.cache.get(key)
      this.cache.delete(key)
      this.put(key, val)
      return val
    }

    return null
  }
}
```

## 实现一个`new`运算符

- 创建一个新对象。

- 将新对象的`__proto__`属性指向这个函数的原型对象。

- 执行这个函数，并把`this`绑定为新对象。

- 如果函数的返回值不是对象，则返回这个新对象。

```ts
function myNew(constructor, ...args) {
  // Object.create以一个现有对象作为原型，创建一个新对象
  const context = Object.create(constructor.prototype)
  const res = constructor.apply(context, args)
  return typeof res === 'object' && res !== null ? res : context
}
```

## 实现一个发布订阅模式

```ts
class EventBus {
  // 存储不同的事件类型
  eventType = new Map()

  // 订阅某个事件类型
  on(type, cb) {
    const callbacks = this.eventType.get(type) || new Set()

    callbacks.add(cb)
    // 每个类型对应一个存储回调函数的set
    this.eventType.set(type, callbacks)
  }

  // 订阅一次
  once(type, cb) {
    const cbWrapper = (...args) => {
      cb(...args)
      this.eventType.get(type).delete(cbWrapper)
    }
    this.on(type, cbWrapper)
  }

  // 发布
  emit(type, ...args) {
    // 没有监听这个事件类型
    if (!this.eventType.has(type)) return
    // 执行这个类型对应的所有回调函数
    this.eventType.get(type).forEach(cb => {
      cb(...args)
    })
  }

  // 解除订阅
  off(type, cb) {
    // 如果只传了类型,就把这个类型对应的所有事件解除监听
    if (arguments.length === 1) {
      this.eventType.get(type).clear()
      return
    }
    this.eventType.get(type).delete(cb)
  }
}
```
