### 1.冒泡排序

依次比较相邻元素大小，如果前面的元素与后面的元素满足给定的排序条件，就将相邻两个元素交换。

```js
function bubbleSort (arr) {
  // 外层循环确定要执行多少次循环比较，每次循环比较确定一个元素的排序位置
  // 如果数组长度为n，则需循环比较n-1次
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = 0; j < arr.length; j++) {
      // 比较相邻元素，并根据排序条件执行交换
      if (arr[j] > arr[j + 1]) {
        const tmp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = tmp
      }
    }
  }
}

// 优化：由于每次循环比较都确定了一个元素的位置，因此在每次循环时可以排除已经确定的元素
function bubbleSort (arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    // 每次循环开始时，排除已经确定的元素个数
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        const tmp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = tmp
      }
    }
  }
}

// 优化：由于每次循环比较都是从左（数组第一位）到右，因此在一个循环比较中，如果没有交换元素，说明数组已经完成排序
function bubbleSort (arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    // 标记是否执行了元素交换
    let flag = false
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        const tmp = arr[j + 1]
        arr[j + 1] = arr[j]
        arr[j] = tmp
        // 元素交换时打上标记
        flag = true
      }
    }
    // 一轮循环比较下来，没有执行元素交换，则退出
    if (!flag) break
  }
}
```

### 2.选择排序

每次从未排序区间中选出最小（或最大）的一个元素，将其放到已排序区间的末尾。

```js
// 假设排序条件为升序
function selectionSort (arr) {
  // 外层循环确定未排序区间 [i, arr.length - 1]
  for (let i = 0; i < arr.length - 1; i++) {
    // 第i小的元素索引（对应未排序区间中最小的元素）
    let k = i

    // 内层循环从未排序区间找到最小的元素
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[k] > arr[j]) {
        // 更新索引
        k = j
      }
    }
    // 将第i小元素与未排序区间的首个元素交换
    const tmp = arr[k]
    arr[k] = arr[i]
    arr[i] = tmp
  }
}
```