
[LeetCode 150](https://leetcode.cn/studyplan/top-interview-150/)

## 数组/字符串
### 1.合并两个有序数组

给你两个按 非递减顺序 排列的整数数组`nums1`和`nums2`，另有两个整数`m`和`n`，分别表示`nums1`和`nums2`中的元素数目。

请你 合并`nums2`到`nums1`中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组`nums1`中。为了应对这种情况，`nums1`的初始长度为`m + n`，其中前`m`个元素表示应合并的元素，后`n`个元素为 0 ，应忽略。`nums2` 的长度为`n`


```ts
// 逆向双指针
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
  let i = nums1.length - 1
  m--
  n--
  // 结束条件为第二个数组全部插入进去
  while (n >= 0) {
    // 比较两个数组，选择一个最大的塞到nums1的尾部
    // 比较一次后，前进一位
    if (nums1[m] > nums2[n]) {
      nums1[i--] = nums1[m--]
    } else {
      nums1[i--] = nums2[n--]
    }
  }
};
```


### 2.移除元素

给你一个数组`nums`和一个值` val`，你需要 原地 移除所有数值等于`val`的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```ts
// 拷贝覆盖
function removeElement(nums: number[], val: number): number {
  // 记录移除后数组的新长度
  let count = 0
  for (const num of nums) {
    // 遍历过程中如果出现数字与需要移除的值不相同时覆盖
    // 记录+1
    if (num !== val) {
      nums[count] = val
      count++
    }
  }
  return count
};
```

### 3.删除有序数组中的重复项

给你一个 升序排列 的数组`nums`，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回`nums`中唯一元素的个数。

```ts
// 数组是有序的，重复元素肯定相邻
function removeDuplicates(nums: number[]): number {
  // 快慢指针，第一个指针i指向第一个数，第二个指针j指向第二个数
  let i = 0;
  for (let j = 1; j < nums.length; j++) {
    // 如果不相等，则把指针i向右移1位，然后覆盖重复元素
    if (nums[i] !== nums[j]) {
      i++
      // 例如 nums = [1, 1, 2], i = 0, j = 1
      // 第一次循环：nums[i] = 1, nums[j] = 1，相等，j++
      // 第二次循环: nums[i] = 1, nums[j] = 2, 不相等，i++, nums[i] = nums[j]，把重复的1改为2
      nums[i] = nums[j]
    }
  }
  // 索引是从0开始，长度要+1
  return i + 1
};
```

### 4.删除有序数组中的重复项 II

给你一个有序数组`nums`，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。


```ts
// 计数法，每个元素最多重复两次
function removeDuplicates(nums) {
  if (nums.length <= 2) return nums.length;
  let i = 0;
  // 记录重复元素
  let count = 0;
  for (let j = 1; j < nums.length; j++) {
    // 重复元素，计数+1
    if (nums[i] === nums[j]) {
      count++;
      // 不重复了，计数清零
    } else count = 0;

    // 计数小于2，说明重复元素不超过2个，可以继续添加
    if (count < 2) {
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
}
```

### 5.多数元素

给定一个大小为`n`的数组`nums`，返回其中的多数元素。多数元素是指在数组中出现次数 大于`⌊ n/2 ⌋`的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```js
function majorityElement(nums) {
  // 排序数组，
  nums.sort((a, b) => a - b);
  // 如果有一个元素出现次数大于n/2，则在数组nums.length/2的位置就是这个数
  return nums[Math.floor(nums.length / 2)];
}


// 另一种解法：哈希
function majorityElement(nums) {
  const map = new Map()
  for (const num of nums) {
    // 存储每个元素出现的次数
    map.set(num, (map.get(num) || 0) + 1)

    // 判断出现次数是否大于数组长度/2
    if (map.get(num) > nums.length / 2) {
        return num
    }
  }
}
```

### 6.旋转数组

给定一个整数数组`nums`，将数组中的元素向右轮转`k`个位置，其中`k`是非负数。

```js
// 把数组向右旋转k个位置，就是当前索引位置加k
// 如果直接i + k的话，前k个索引位置就没有元素了，因此需要 i + k % nums.length
// i + k < nums.length时，就是i + k的位置，而此时i + k % nums.length，还是i + k
// i + k > nums.length时，就是i + k % nums.length的位置
function rotate(nums, k) {
  // 使用另一个数组依次存储旋转位置后的每个元素
  const newArr = []
  const len = nums.length
  for (let i = 0; i < len; i++) {
    // 例如，nums = [1, 2, 3, 4], k = 2
    // 当i = 0时，(0 + 2) % 4 = 2, 此时newArr[2] = nums[i]
    // 1被移动到了原先3的位置
    // 当i = 1时，(1 + 2) % 4 = 3, 2被移动到了4的位置
    // 以此类推...
    newArr[(i + k) % len] = nums[i]
  }

  // 再将新数组依次拷贝到原数组
  for (let i = 0; i < len; i++) {
    nums[i] = newArr[i]
  }
}

// 另一种解法：数组翻转
const reverse = (nums, l, r) => {
  while(l < r) {
    const temp = nums[l]
    nums[l] = nums[r]
    nums[r] = temp
    l++
    r--
  }
}

function rotate(nums, k) {
  // 例如nums = [1, 2, 3, 4], k = 2
  k = k % nums.length
  // 先翻转整个数组 -> [4, 3, 2, 1]
  reverse(nums, 0, nums.length - 1)
  // 再翻转0到k - 1区间 -> [3, 4, 2, 1]
  reverse(nums, 0, k - 1)
  // 最后翻转k到数组长度减1的区间 -> [3, 4, 1, 2]
  reverse(nums, k, nums.length - 1)
};
```

### 7. 买卖股票的最佳时机

给定一个数组`prices`，它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回`0`。


```js
// 贪心算法，取最左最小值，取最右最大值，差值即为最大利润
function maxProfit(prices) {
  // 边界条件
  if (prices.length === 0) return 0;
  // 最低买点
  let min = prices[0];
  // 最大收入
  let max = 0;

  for (let i = 1; i < prices.length; i++) {
    // 更新最低买点
    min = Math.min(min, prices[i]);
    // 更新最大利润
    max = Math.max(max, prices[i] - min);
  }

  return max;
};

// 另一种解法：动态规划
// 定义状态，i表示天数，0：不持有股票，1：持有股票
// 第i天不持有，由第i-1天不持有然后不操作 和 第i-1天持有然后卖出，两种情况的最大值
// dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])

// 第i天持有 由 第i-1天持有然后不操作 和 第i-1天买入 两种情况的最大值
// dp[i][1] = Math.max(dp[i - 1][1], -prices[i])

// 最大收益为：dp[n - 1][0]而不是dp[n - 1][1]
// 最后一天不持有比持有更高
function maxProfit (prices) {
  const len = prices.length;
  const dp = new Array(len);
  dp[0] = [0, -prices[0]];
  for (let i = 1; i < len; i++) {
    dp[i] = new Array(2);
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
  }
  return dp[n - 1][0];
};


// 状态压缩
// dp[i][0]和dp[i][1]都只和昨天（day i-1）的状态有关，和之前的状态无关。
// 因此没必要用 dp 数组存过去所有的状态，用两个变量保存，在迭代中更新即可：
function maxProfit(prices) {
  const len = prices.length;
  let unfold = 0;
  let fold = -prices[0];

  for (let i = 1; i < len; i++) {
    unfold = Math.max(unfold, fold + prices[i]);
    fold = Math.max(fold, -prices[i]);
  }

  return unfold;
}

```

### 8.买卖股票的最佳时机 II


给你一个整数数组`prices`，其中`prices[i]`表示某支股票第`i`天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

```js
// 和上面买卖股票的最佳时机相比，可多次卖出

// 贪心算法，只要后一天比前一天大，就卖出
function maxProfit(prices) {
  let profit = 0; // 收益
  for (let i = 1; i < prices.length; i++) {
    const diff = prices[i] - prices[i - 1];
    if (diff > 0) {
      // 差价大于0
      profit += diff;
    }
  }
  return profit;
}

// 另一种解法：动态规划
// 定义状态，i表示天数，0：不持有股票，1：持有股票
// 第i天不持有，由第i-1天不持有然后不操作 和 第i-1天持有然后卖出，两种情况的最大值
// dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])

// 第 i 天手里有股票，至今（第 i 天）的最大收益。
// 第i天持有 由 第i-1天持有然后不操作 和 第i-1天不持有然后买入 两种情况的最大值
// dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i])
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) {
    return 0;
  }
  // 例如pricres = [1, 5, 3, 6]
  // dp = [[0, -1], [Math.max(0, -1 + 5), Math.max(-1, 0 - 5)], [Math.max(4, -1 + 3), Math.max(-1, 4 - 3)], [Math.max(4, 1 + 6), Math.max(1, 4 - 6)]]
  const dp = new Array(len);
  dp[0] = [0, -prices[0]];
  for (let i = 1; i < len; i++) {
    dp[i] = new Array(2);
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
  }
  return dp[len - 1][0];
}

// 状态压缩
// dp[i][0]和dp[i][1]都只和昨天（day i-1）的状态有关，和之前的状态无关。
// 因此没必要用 dp 数组存过去所有的状态，用两个变量保存，在迭代中更新即可：
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) return 0

  // 当天没有持有的情况下，最大的利润
  let unhold = 0
  // 当天持有的情况下，最大的利润
  let hold = -prices[0]

  for (let i = 1; i < prices.length; i++) {
    // 求今天的持有时，要用到昨天的不持有，暂存一下昨天的不持有
    const temp = unhold
    unhold = Math.max(unhold, hold + prices[i])
    hold = Math.max(hold, temp - prices[i])
  }

  return unhold
}
```

### 9.跳跃游戏
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

```js
// 贪心算法
// 计算出该路线能到的最远距离，判断最远的距离是否超过了该路径或者刚好到达终点
// 每一次都计算当前位置以及以前能走到的最远距离
function canJump(nums) {
  // 最远可以到达的位置
  let max = nums[0];

  for (let i = 0; i < nums.length; i++) {
    // 如果当前位置在最远可到达的位置范围内
    // 就尝试更新最远可到达的位置
    if (i <= max) {
      max = Math.max(max, i + nums[i]);

      if (max >= nums.length - 1) return true;
    } else {
      return false;
    }
  }
  return true;
}
```

### 10.跳跃游戏 II

给定一个长度为`n`的`0`索引整数数组`nums`。初始位置为`nums[0]`。

每个元素`nums[i]`表示从索引`i`向前跳转的最大长度。换句话说，如果你在`nums[i]`处，你可以跳转到任意`nums[i + j]`处:

`0 <= j <= nums[i]`
`i + j < n`
返回到达`nums[n - 1]`的最小跳跃次数。生成的测试用例可以到达`nums[n - 1]`。

```js
todo
```


### 11.H 指数

给你一个整数数组`citations`，其中`citations[i]`表示研究者的第`i`篇论文被引用的次数。计算并返回该研究者的`h`指数。

根据维基百科上`h`指数的定义：`h`代表“高引用次数” ，一名科研人员的`h`指数 是指他（她）至少发表了`h`篇论文，并且每篇论文 至少 被引用`h`次。如果`h`有多种可能的值,`h`指数 是其中最大的那个。

```js
todo
```

### 12.O(1) 时间插入、删除和获取随机元素

实现`RandomizedSet`类：

`RandomizedSet()`初始化`RandomizedSet`对象
`bool insert(int val)`当元素`val`不存在时，向集合中插入该项，并返回`true`；否则，返回`false`。
`bool remove(int val)`当元素`val`存在时，从集合中移除该项，并返回`true`；否则，返回`false`。
`int getRandom()`随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为`O(1)`。

```js
// set
function RandomizedSet() {
  this.set = new Set();
}

RandomizedSet.prototype.insert = function (val) {
  if (this.set.has(val)) {
    return false;
  }
  this.set.add(val);
  return true;
};

RandomizedSet.prototype.remove = function (val) {
  if (!this.set.has(val)) {
    return false;
  }
  this.set.delete(val);
  return true;
};

// 在取值时，需要先转换成数组，时间复杂度不是O(1)
RandomizedSet.prototype.getRandom = function () {
  return Array.from(this.set)[Math.floor(Math.random() * this.set.size)];
};


// 另一种解法 array + map
function RandomizedSet() {
  this.map = new Map();
  this.arr = [];
}

RandomizedSet.prototype.insert = function (val) {
  if (this.map.has(val)) {
    return false;
  }
  // 记录值和索引 { val: idx }
  this.map.set(val, this.arr.length);
  this.arr.push(val);
  return true;
};

RandomizedSet.prototype.remove = function (val) {
  if (!this.map.has(val)) {
    return false;
  }
  // 获取这个值的索引
  const idx = this.map.get(val);

  // 将最后一个值放到这个索引上
  this.arr[idx] = this.arr[this.arr.length - 1];
  // 更新最后一个值的索引
  this.map.set(this.arr[idx], idx);
  // 然后再删除最后一个元素，就相当于删除了这个值, 且pop时间复杂度是O(1)
  this.arr.pop();

  this.map.delete(val);

  return true;
};

RandomizedSet.prototype.getRandom = function () {
  return this.arr[Math.floor(Math.random() * this.arr.length)];
};
```

### 13.除自身以外数组的乘积

给你一个整数数组`nums`，返回 数组`answer`，其中`answer[i]`等于`nums`中除`nums[i]`之外其余各元素的乘积 。

题目数据 保证 数组`nums`之中任意元素的全部前缀元素和后缀的乘积都在`32 位`整数范围内。

请不要使用除法，且在`O(n)`时间复杂度内完成此题。

```js
// 求这个数除它自身之外其他所有数的乘积 = 该数左边所有数的乘积 * 该数右边所有数的乘积
function productExceptSelf(nums) {
  const len = nums.length;
  // ans[i]等于数组i左侧所有数字的乘积
  // 第一个数左边没有其他数，因此乘积为1
  const ans = [1];
  let r = 1;
  for (let i = 1; i < len; i++) {
    ans[i] = ans[i - 1] * nums[i - 1];
  }

  // R即所有右侧元素的乘积
  // 第一次遍历时，i为最后一个索引，右侧没有元素，因此R为1
  for (let i = len - 1; i >= 0; i--) {
    ans[i] = ans[i] * r;
    r *= nums[i];
  }
  return ans;
}
```

### 14.加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

```js
todo
```


### 15.分发糖果

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

```js
todo
```

### 16.接雨水

```js
todo
```


### 17. 罗马数字转整数


例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

```js
// 哈希
function romanToInt(s) {
  // map中存放罗马数字和阿拉伯数字的对应关系，其中阿拉伯数字越大，权重越大
  // I = 1, IV = 5 - 1 = 4
  const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 };
  // 例如，s = LVIII，arr = ['L', 'V', 'I', 'I', 'I']，int = 0
  // i = 0, map[arr[0]] = 50, map[arr[1]] = 5, 50 > 5, int = 0 + 50 = 50
  // i = 1, map[arr[1]] = 5, map[arr[2]] = 1, 5 > 1, int = 50 + 5 = 55
  // i = 2, map[arr[2]] = 1, map[arr[3]] = 1, 1 = 1, int = 55 + 1 = 56
  // i = 3, map[arr[3]] = 1, map[arr[4]] = 1, 1 = 1, int = 56 + 1 = 57
  // i = 4, map[arr[4]] = 1, map[arr[5]] = undefined, int = 57 + 1 = 58
  let int = 0;
  const arr = s.split("");

  for (let i = 0; i < arr.length; i++) {
    // 后面的值权重大于前面的值，则减去前面的值
    if (map[arr[i]] < map[arr[i + 1]]) {
      int -= map[arr[i]];
    } else {
      // 后面的值权重小于前面的值，则加上前面的值
      int += map[arr[i]];
    }
  }

  return int;
}
```

### 18.整数转罗马数字

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。

```js
// 哈希
function intToRoman(num) {
  // map存储罗马数字和对应的整数
  const map = new Map([
    ["M", 1000],
    ["CM", 900],
    ["D", 500],
    ["CD", 400],
    ["C", 100],
    ["XC", 90],
    ["L", 50],
    ["XL", 40],
    ["X", 10],
    ["IX", 9],
    ["V", 5],
    ["IV", 4],
    ["I", 1],
  ]);

  let roman = "";
  // 从大到小遍历map
  for (const [symbol, number] of map) {
    // 不断减去当前罗马数字对应的整数，直到num小于当前整数
    while (num >= number) {
      num -= number;
      // 拼接对应的罗马数字
      roman += symbol;
    }
  }
  return roman;
}
```

### 19.最后一个单词的长度

```js

```


## 双指针


### 25.验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串`s`，如果它是 回文串 ，返回`true`；否则，返回`false`


```js
// 左右指针，一个指向头，一个指向尾
function isPalindrome(s: string) {
  let l = 0,
    r = s.length - 1;
  const reg = /^[a-zA-Z0-9]$/;
  while (l < r) {
    // 依次比较，相等就把两个指针都移一位
    if (s[l].toLowerCase() === s[r].toLowerCase()) {
      l++;
      r--;
    // 非字母数字，就把指针移一位
    } else if (!reg.test(s[l])) {
      l++;
    } else if (!reg.test(s[r])) {
      r--;
    // 不等则不满足条件
    } else {
      return false;
    }
  }

  return true;
}
```

### 26.判断子序列

给定字符串`s`和`t`，判断`s`是否为`t`的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

```js
// 双指针，分别指向两个字符的初始位置
function isSubsequence(s, t) {
  let i = 0, j = 0
  
  // 因为是判断短串在长串中是否匹配，所以短串走完了就说明能匹配上
  while(i < s.length && j < t.length) {
    // 如果指向的字符相同，短串指针移动一位
    if (s[i] === t[j]) {
      i++
    } 
    j++
  }
  return i === s.length
}

// 另一种解法：动态规划todo
```

### 27.两数之和 II - 输入有序数组

给你一个下标从`1`开始的整数数组`numbers`，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 `target`的两个数。如果设这两个数分别是`numbers[index1]`和`numbers[index2]`，则`1 <= index1 < index2 <= numbers.length`。

以长度为`2`的整数数组`[index1, index2]`的形式返回这两个整数的下标`index1`和`index2`。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

```js
// 左右指针，一个指向头，一个指向尾
function twoSum(numbers, target) {
  let l = 0,  r = numbers.length - 1

  // 因为numbers是递增排列的，所以如果指针指向的两个元素之和大于目标值
  // 则尾部指针向前移动一位（越往前元素越小，小于目标值，则头部指针向后移动一位（越往后元素越大
  while (l < r) {
    if (numbers[l] + numbers[r] > target) {
      r--
    } else if (numbers[l] + numbers[r] < target) {
      l++
    } else {
      return [l + 1, r + 1]
    }
  }
};
```

### 28.盛最多水的容器

给定一个长度为`n`的整数数组`height`。有`n`条垂线，第`i`条线的两个端点是`(i, 0)`和`(i, height[i])`。

找出其中的两条线，使得它们与`x`轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

```js

```

## 滑动窗口

### 长度最小的子数组

```js
function minSubArrayLen(target, nums) {
  // l，r维护一个滑动窗口
  let l = 0,
    r = 0,
    // 记录窗口内值的和
    sum = 0,
    // 记录最小窗口长度
    min = Infinity;

  while (r < nums.length) {
    sum += nums[r];

    // 当窗口内值的和大于等于target时，就找到了一个满足条件的子数组
    while (sum >= target) {
      // 记录长度
      min = Math.min(r - l + 1, min);
      // 移动左指针，缩小窗口
      sum -= nums[l];
      l++;
    }
    r++;
  }

  return min === Infinity ? 0 : min;
}
```


### 无重复字符的最长子串

给定一个字符串`s` ，请你找出其中不含有重复字符的 最长子串 的长度。

```ts
// 用字符串（也可以换成数组）维护一个滑动窗口
function lengthOfLongestSubstring(s: string) {
  let max = 0;
  let str = "";
  for (let i = 0; i < s.length; i++) {
    // 判断这个窗口中是否存在这个字符
    const idx = str.indexOf(s[i]);

    if (idx === -1) {
      // 不存在则扩大窗口
      str += s[i];
      // 更新窗口的最大值
      max = Math.max(max, str.length);
    } else {
      // 存在则移动窗口
      // abc => abca => bca
      str = str.substr(idx + 1) + s[i];
    }
  }
  return max;
}

// 另一种思路
// 双指针维护滑动窗口
function lengthOfLongestSubstring(s: string) {
  let max = 0;
  for (let i = 0, j = 0; j < s.length; j++) {
    // 判断这个窗口中是否存在s[j]
    const idx = s.substring(i, j).indexOf(s[j]);
    // 如果存在，则缩小窗口
    if (idx !== -1) {
      i = i + idx + 1;
    }
    // 更新窗口最大值
    max = Math.max(max, j - i + 1);
  }
  return max;
}
```





## 哈希表

### 赎金信

给你两个字符串：`ransomNote`和`magazine`，判断`ransomNote`能不能由`magazine`里面的字符构成。

如果可以，返回`true`；否则返回`false`。

`magazine`中的每个字符只能在`ransomNote`中使用一次。

```js
// 字符统计
function canConstruct(ransomNote, magazine) {
  // 边界条件
  if (ransomNote.length > magazine.length) {
    return false;
  }

  // 用一个map存储ransomNote中字符的出现次数（也可以存magazine中字符的出现次数）
  const map = new Map();

  // 例如 ransomNote = "aab",  map = {a:2, b:1}
  for (const str of ransomNote) {
    map.set(str, (map.get(str) || 0) + 1);
  }

  // 遍历magazine，如果map中存在该字符，则将其次数减1
  for (const str of magazine) {
    if (map.has(str)) {
      const count = map.get(str) - 1;
      // 如果次数为0，则删除该字符
      if (count === 0) {
        map.delete(str);
      } else {
        map.set(str, count);
      }
    }

    // 如果map为空，则说明ransomNote中的字符都在magazine中出现过
    if (map.size === 0) {
      return true;
    }
  }

  return false;
}
```

### 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```js
const isIsomorphic = function (s, t) {
  if (s.length !== t.length) {
    return false;
  }
  const sMap = new Map();
  const tMap = new Map();

  for (let i = 0; i < s.length; i++) {
    const a = s[i];
    const b = t[i];

    if (
      (sMap.has(a) && sMap.get(a) !== b) ||
      (tMap.has(b) && tMap.get(b) !== a)
    )
      return false;

    sMap.set(a, b);

    tMap.set(b, a);
  }

  return true;
};


// 同构字符串，每个字符 首次出现、最后出现、指定位出现 索引始终相同
function isIsomorphic(s, t) {
  // 边界条件，长度不同，直接返回false
  if (s.length !== t.length) {
    return false;
  }
  // 例如 s = "foo", t = "bar", i = 2
  // s.indexOf(s[2]) = 1, t.indexOf(t[2]) = 2，s和t不同构
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
      return false;
    }
  }
  return true;
}
```

### 两数之和

给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出 和为目标值`target`的那两个整数，并返回它们的数组下标。

```ts
// 暴力枚举
function twoSum(nums: number[], target: number) {
  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];

    for (let j = i + 1; j < nums.length; j++) {
      if (el + nums[j] === target) {
        return [i, j];
      }
    }
  }
}


// 哈希
function twoSum(nums: number[], target: number) {
  // 用 map 存储遍历过的元素和对应的索引
  const map = new Map<number, number>()

  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];
    // 每遍历一个元素，看看 map 中是否存在满足要求的目标数字
    if (map.has(target - el)) {
      return [map.get(target - el), i];
    }
    
    map.set(el, i)
  }
}
```

### 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的所有字母得到的一个新单词。


```ts
function groupAnagrams(strs: string[]): string[][] {
  const map = new Map<string, string[]>();
  for (const str of strs) {
    // 把遍历到的字符串按照字母顺序排序
    const k = str.split("").sort().toString();

    // 作为map的key，ate, eat, tea 排序后都是aet，即相同的key
    const list = map.get(k) || [];
    list.push(str);
    map.set(k, list);
  }

  // Array.from 从可迭代或类数组对象创建一个新的浅拷贝的数组实例
  return Array.from(map.values());
}
```

### 最长连续序列

给定一个未排序的整数数组`nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

```ts
function longestConsecutive(nums: Number[]): number {
  if (nums.length === 0) return 0;
  // 从小到大排序
  nums.sort((a, b) => a - b);
  let max = 1;

  // 每次连续的计数
  let count = 1;

  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];
    // 相邻两项相同，跳过
    if (el === nums[i + 1]) continue;
    // 连续项 计数+1
    if (el + 1 === nums[i + 1]) {
      count++;

      // 中断，将count与max比较，取最大值
    } else {
      max = Math.max(count, max);

      count = 1;
    }
  }

  return max;
}
```