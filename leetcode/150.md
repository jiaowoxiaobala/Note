
[LeetCode 150](https://leetcode.cn/studyplan/top-interview-150/)

## 数组/字符串
### 1.合并两个有序数组

给你两个按 非递减顺序 排列的整数数组`nums1`和`nums2`，另有两个整数`m`和`n`，分别表示`nums1`和`nums2`中的元素数目。

请你 合并`nums2`到`nums1`中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组`nums1`中。为了应对这种情况，`nums1`的初始长度为`m + n`，其中前`m`个元素表示应合并的元素，后`n`个元素为 0 ，应忽略。`nums2` 的长度为`n`


```ts
// 逆向双指针
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
  let i = nums1.length - 1
  m--
  n--
  // 结束条件为第二个数组全部插入进去
  while (n >= 0) {
    // 比较两个数组，选择一个最大的塞到nums1的尾部
    // 比较一次后，前进一位
    if (nums1[m] > nums2[n]) {
      nums1[i--] = nums1[m--]
    } else {
      nums1[i--] = nums2[n--]
    }
  }
};
```


### 2.移除元素

给你一个数组`nums`和一个值` val`，你需要 原地 移除所有数值等于`val`的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```ts
// 拷贝覆盖
function removeElement(nums: number[], val: number): number {
  // 记录移除后数组的新长度
  let count = 0
  for (const num of nums) {
    // 遍历过程中如果出现数字与需要移除的值不相同时覆盖
    // 记录+1
    if (num !== val) {
      nums[count] = val
      count++
    }
  }
  return count
};
```

### 3.删除有序数组中的重复项

给你一个 升序排列 的数组`nums`，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回`nums`中唯一元素的个数。

```ts
// 数组是有序的，重复元素肯定相邻
function removeDuplicates(nums: number[]): number {
  // 快慢指针，第一个指针i指向第一个数，第二个指针j指向第二个数
  let i = 0;
  for (let j = 1; j < nums.length; j++) {
    // 如果不相等，则把指针i向右移1位，然后覆盖重复元素
    if (nums[i] !== nums[j]) {
      i++
      // 例如 nums = [1, 1, 2], i = 0, j = 1
      // 第一次循环：nums[i] = 1, nums[j] = 1，相等，j++
      // 第二次循环: nums[i] = 1, nums[j] = 2, 不相等，i++, nums[i] = nums[j]，把重复的1改为2
      nums[i] = nums[j]
    }
  }
  // 索引是从0开始，长度要+1
  return i + 1
};
```

### 4.删除有序数组中的重复项 II

给你一个有序数组`nums`，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。


```ts
// 计数法，每个元素最多重复两次
function removeDuplicates(nums) {
  if (nums.length <= 2) return nums.length;
  let i = 0;
  // 记录重复元素
  let count = 0;
  for (let j = 1; j < nums.length; j++) {
    // 重复元素，计数+1
    if (nums[i] === nums[j]) {
      count++;
      // 不重复了，计数清零
    } else count = 0;

    // 计数小于2，说明重复元素不超过2个，可以继续添加
    if (count < 2) {
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
}
```

### 5.多数元素

给定一个大小为`n`的数组`nums`，返回其中的多数元素。多数元素是指在数组中出现次数 大于`⌊ n/2 ⌋`的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```js
function majorityElement(nums) {
  // 排序数组，
  nums.sort((a, b) => a - b);
  // 如果有一个元素出现次数大于n/2，则在数组nums.length/2的位置就是这个数
  return nums[Math.floor(nums.length / 2)];
}


// 另一种解法：哈希
function majorityElement(nums) {
  const map = new Map()
  for (const num of nums) {
    // 存储每个元素出现的次数
    map.set(num, (map.get(num) || 0) + 1)

    // 判断出现次数是否大于数组长度/2
    if (map.get(num) > nums.length / 2) {
        return num
    }
  }
}
```

### 6.旋转数组

给定一个整数数组`nums`，将数组中的元素向右轮转`k`个位置，其中`k`是非负数。

```js
// 把数组向右旋转k个位置，就是当前索引位置加k
// 如果直接i + k的话，前k个索引位置就没有元素了，因此需要 i + k % nums.length
// i + k < nums.length时，就是i + k的位置，而此时i + k % nums.length，还是i + k
// i + k > nums.length时，就是i + k % nums.length的位置
function rotate(nums, k) {
  // 使用另一个数组依次存储旋转位置后的每个元素
  const newArr = []
  const len = nums.length
  for (let i = 0; i < len; i++) {
    // 例如，nums = [1, 2, 3, 4], k = 2
    // 当i = 0时，(0 + 2) % 4 = 2, 此时newArr[2] = nums[i]
    // 1被移动到了原先3的位置
    // 当i = 1时，(1 + 2) % 4 = 3, 2被移动到了4的位置
    // 以此类推...
    newArr[(i + k) % len] = nums[i]
  }

  // 再将新数组依次拷贝到原数组
  for (let i = 0; i < len; i++) {
    nums[i] = newArr[i]
  }
}

// 另一种解法：数组翻转
const reverse = (nums, l, r) => {
  while(l < r) {
    const temp = nums[l]
    nums[l] = nums[r]
    nums[r] = temp
    l++
    r--
  }
}

function rotate(nums, k) {
  // 例如nums = [1, 2, 3, 4], k = 2
  k = k % nums.length
  // 先翻转整个数组 -> [4, 3, 2, 1]
  reverse(nums, 0, nums.length - 1)
  // 再翻转0到k - 1区间 -> [3, 4, 2, 1]
  reverse(nums, 0, k - 1)
  // 最后翻转k到数组长度减1的区间 -> [3, 4, 1, 2]
  reverse(nums, k, nums.length - 1)
};
```

### 7. 买卖股票的最佳时机

给定一个数组`prices`，它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回`0`。


```js
// 贪心算法，取最左最小值，取最右最大值，差值即为最大利润
function maxProfit(prices) {
  // 边界条件
  if (prices.length === 0) return 0;
  // 最低买点
  let min = prices[0];
  // 最大收入
  let max = 0;

  for (let i = 1; i < prices.length; i++) {
    // 更新最低买点
    min = Math.min(min, prices[i]);
    // 更新最大利润
    max = Math.max(max, prices[i] - min);
  }

  return max;
};

// 另一种解法：动态规划
// 定义状态，i表示天数，0：不持有股票，1：持有股票
// 第i天不持有，由第i-1天不持有然后不操作 和 第i-1天持有然后卖出，两种情况的最大值
// dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])

// 第i天持有 由 第i-1天持有然后不操作 和 第i-1天买入 两种情况的最大值
// dp[i][1] = Math.max(dp[i - 1][1], -prices[i])

// 最大收益为：dp[n - 1][0]而不是dp[n - 1][1]
// 最后一天不持有比持有更高
function maxProfit (prices) {
  const len = prices.length;
  const dp = new Array(len);
  dp[0] = [0, -prices[0]];
  for (let i = 1; i < len; i++) {
    dp[i] = new Array(2);
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
  }
  return dp[n - 1][0];
};


// 状态压缩
// dp[i][0]和dp[i][1]都只和昨天（day i-1）的状态有关，和之前的状态无关。
// 因此没必要用 dp 数组存过去所有的状态，用两个变量保存，在迭代中更新即可：
function maxProfit(prices) {
  const len = prices.length;
  let unfold = 0;
  let fold = -prices[0];

  for (let i = 1; i < len; i++) {
    unfold = Math.max(unfold, fold + prices[i]);
    fold = Math.max(fold, -prices[i]);
  }

  return unfold;
}

```

### 8.买卖股票的最佳时机 II


给你一个整数数组`prices`，其中`prices[i]`表示某支股票第`i`天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

```js
// 和上面买卖股票的最佳时机相比，可多次卖出

// 贪心算法，只要后一天比前一天大，就卖出
function maxProfit(prices) {
  let profit = 0; // 收益
  for (let i = 1; i < prices.length; i++) {
    const diff = prices[i] - prices[i - 1];
    if (diff > 0) {
      // 差价大于0
      profit += diff;
    }
  }
  return profit;
}

// 另一种解法：动态规划
// 定义状态，i表示天数，0：不持有股票，1：持有股票
// 第i天不持有，由第i-1天不持有然后不操作 和 第i-1天持有然后卖出，两种情况的最大值
// dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])

// 第 i 天手里有股票，至今（第 i 天）的最大收益。
// 第i天持有 由 第i-1天持有然后不操作 和 第i-1天不持有然后买入 两种情况的最大值
// dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i])
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) {
    return 0;
  }
  // 例如pricres = [1, 5, 3, 6]
  // dp = [[0, -1], [Math.max(0, -1 + 5), Math.max(-1, 0 - 5)], [Math.max(4, -1 + 3), Math.max(-1, 4 - 3)], [Math.max(4, 1 + 6), Math.max(1, 4 - 6)]]
  const dp = new Array(len);
  dp[0] = [0, -prices[0]];
  for (let i = 1; i < len; i++) {
    dp[i] = new Array(2);
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
  }
  return dp[len - 1][0];
}

// 状态压缩
// dp[i][0]和dp[i][1]都只和昨天（day i-1）的状态有关，和之前的状态无关。
// 因此没必要用 dp 数组存过去所有的状态，用两个变量保存，在迭代中更新即可：
function maxProfit(prices) {
  const len = prices.length;
  if (len < 2) return 0

  // 当天没有持有的情况下，最大的利润
  let unhold = 0
  // 当天持有的情况下，最大的利润
  let hold = -prices[0]

  for (let i = 1; i < prices.length; i++) {
    // 求今天的持有时，要用到昨天的不持有，暂存一下昨天的不持有
    const temp = unhold
    unhold = Math.max(unhold, hold + prices[i])
    hold = Math.max(hold, temp - prices[i])
  }

  return unhold
}
```

### 9.跳跃游戏
给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

```js
// 贪心算法
// 计算出该路线能到的最远距离，判断最远的距离是否超过了该路径或者刚好到达终点
// 每一次都计算当前位置以及以前能走到的最远距离
function canJump(nums) {
  // 最远可以到达的位置
  let max = nums[0];

  for (let i = 0; i < nums.length; i++) {
    // 如果当前位置在最远可到达的位置范围内
    // 就尝试更新最远可到达的位置
    if (i <= max) {
      max = Math.max(max, i + nums[i]);

      if (max >= nums.length - 1) return true;
    } else {
      return false;
    }
  }
  return true;
}
```

### 10.跳跃游戏 II

给定一个长度为`n`的`0`索引整数数组`nums`。初始位置为`nums[0]`。

每个元素`nums[i]`表示从索引`i`向前跳转的最大长度。换句话说，如果你在`nums[i]`处，你可以跳转到任意`nums[i + j]`处:

`0 <= j <= nums[i]`
`i + j < n`
返回到达`nums[n - 1]`的最小跳跃次数。生成的测试用例可以到达`nums[n - 1]`。

```js
// 求最小跳跃次数 = 求每次跳跃范围内跳到最远位置的点
function jump (nums) {
  // 记录每次的跳跃边界
  let end = 0
  // 当前边界内跳到的最远位置
  let longest = 0
  // 跳跃次数
  let steps = 0
  for (let i = 0; i < nums.length - 1; i++) {
    // 更新边界内的最远位置
    longest = Math.max(nums[i] + i, longest)
    // 当遍历到跳跃边界时，已经知道哪个点是局部最优解，要做出选择，开始跳跃
    if (i === end) {
      // 更新跳跃边界
      end = longest
      // 跳跃次数 + 1
      steps++
    }
    // 可以跳到最后一个位置了
    if (end >= nums.length - 1) {
      break
    }
  }

  return steps
}
```


### 11.H 指数

给你一个整数数组`citations`，其中`citations[i]`表示研究者的第`i`篇论文被引用的次数。计算并返回该研究者的`h`指数。

根据维基百科上`h`指数的定义：`h`代表“高引用次数” ，一名科研人员的`h`指数 是指他（她）至少发表了`h`篇论文，并且每篇论文 至少 被引用`h`次。如果`h`有多种可能的值,`h`指数 是其中最大的那个。

```js
todo
```

### 12.O(1) 时间插入、删除和获取随机元素

实现`RandomizedSet`类：

`RandomizedSet()`初始化`RandomizedSet`对象
`bool insert(int val)`当元素`val`不存在时，向集合中插入该项，并返回`true`；否则，返回`false`。
`bool remove(int val)`当元素`val`存在时，从集合中移除该项，并返回`true`；否则，返回`false`。
`int getRandom()`随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为`O(1)`。

```js
// set
function RandomizedSet() {
  this.set = new Set();
}

RandomizedSet.prototype.insert = function (val) {
  if (this.set.has(val)) {
    return false;
  }
  this.set.add(val);
  return true;
};

RandomizedSet.prototype.remove = function (val) {
  if (!this.set.has(val)) {
    return false;
  }
  this.set.delete(val);
  return true;
};

// 在取值时，需要先转换成数组，时间复杂度不是O(1)
RandomizedSet.prototype.getRandom = function () {
  return Array.from(this.set)[Math.floor(Math.random() * this.set.size)];
};


// 另一种解法 array + map
function RandomizedSet() {
  this.map = new Map();
  this.arr = [];
}

RandomizedSet.prototype.insert = function (val) {
  if (this.map.has(val)) {
    return false;
  }
  // 记录值和索引 { val: idx }
  this.map.set(val, this.arr.length);
  this.arr.push(val);
  return true;
};

RandomizedSet.prototype.remove = function (val) {
  if (!this.map.has(val)) {
    return false;
  }
  // 获取这个值的索引
  const idx = this.map.get(val);

  // 将最后一个值放到这个索引上
  this.arr[idx] = this.arr[this.arr.length - 1];
  // 更新最后一个值的索引
  this.map.set(this.arr[idx], idx);
  // 然后再删除最后一个元素，就相当于删除了这个值, 且pop时间复杂度是O(1)
  this.arr.pop();

  this.map.delete(val);

  return true;
};

RandomizedSet.prototype.getRandom = function () {
  return this.arr[Math.floor(Math.random() * this.arr.length)];
};
```

### 13.除自身以外数组的乘积

给你一个整数数组`nums`，返回 数组`answer`，其中`answer[i]`等于`nums`中除`nums[i]`之外其余各元素的乘积 。

题目数据 保证 数组`nums`之中任意元素的全部前缀元素和后缀的乘积都在`32 位`整数范围内。

请不要使用除法，且在`O(n)`时间复杂度内完成此题。

```js
// 求这个数除它自身之外其他所有数的乘积 = 该数左边所有数的乘积 * 该数右边所有数的乘积
function productExceptSelf(nums) {
  const len = nums.length;
  // ans[i]等于数组i左侧所有数字的乘积
  // 第一个数左边没有其他数，因此乘积为1
  const ans = [1];
  let r = 1;
  for (let i = 1; i < len; i++) {
    ans[i] = ans[i - 1] * nums[i - 1];
  }

  // R即所有右侧元素的乘积
  // 第一次遍历时，i为最后一个索引，右侧没有元素，因此R为1
  for (let i = len - 1; i >= 0; i--) {
    ans[i] = ans[i] * r;
    r *= nums[i];
  }
  return ans;
}
```

### 14.加油站

在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。

```js
todo
```


### 15.分发糖果

n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。

```js
function candy (ratings) {
  // 每个孩子至少分配到1个糖果
  const candys = new Array(ratings.length).fill(1)
  // 先正序遍历一次，满足左规则
  for (let i = 1; i < ratings.length; i++) {
    // 后一个比前一个的评分高
    if (ratings[i] > ratings[i - 1]) {
      // 得到的糖果比前一个多一个
      candys[i] = candys[i - 1] + 1
    }
  }
  // 再反序遍历一次，在保护原有左规则的前提下实现右规则
  // 满足右规则毫无疑问：+1即可，同时为了保护左规则需要两者取最大值。
  for (let i = ratings.length - 2; i >= 0; i--) {
    // 前一个比后一个的评分高
    if (ratings[i] > ratings[i + 1]) {
      candys[i] = Math.max(candys[i], candys[i + 1] + 1)
    }
  }

  return candys.reduce((a, b) => a + b)
}
```

### 16.接雨水

```js
todo
```


### 17. 罗马数字转整数


例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

```js
// 哈希
function romanToInt(s) {
  // map中存放罗马数字和阿拉伯数字的对应关系，其中阿拉伯数字越大，权重越大
  // I = 1, IV = 5 - 1 = 4
  const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 };
  // 例如，s = LVIII，arr = ['L', 'V', 'I', 'I', 'I']，int = 0
  // i = 0, map[arr[0]] = 50, map[arr[1]] = 5, 50 > 5, int = 0 + 50 = 50
  // i = 1, map[arr[1]] = 5, map[arr[2]] = 1, 5 > 1, int = 50 + 5 = 55
  // i = 2, map[arr[2]] = 1, map[arr[3]] = 1, 1 = 1, int = 55 + 1 = 56
  // i = 3, map[arr[3]] = 1, map[arr[4]] = 1, 1 = 1, int = 56 + 1 = 57
  // i = 4, map[arr[4]] = 1, map[arr[5]] = undefined, int = 57 + 1 = 58
  let int = 0;
  const arr = s.split("");

  for (let i = 0; i < arr.length; i++) {
    // 后面的值权重大于前面的值，则减去前面的值
    if (map[arr[i]] < map[arr[i + 1]]) {
      int -= map[arr[i]];
    } else {
      // 后面的值权重小于前面的值，则加上前面的值
      int += map[arr[i]];
    }
  }

  return int;
}
```

### 18.整数转罗马数字

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。

```js
// 哈希
function intToRoman(num) {
  // map存储罗马数字和对应的整数
  const map = new Map([
    ["M", 1000],
    ["CM", 900],
    ["D", 500],
    ["CD", 400],
    ["C", 100],
    ["XC", 90],
    ["L", 50],
    ["XL", 40],
    ["X", 10],
    ["IX", 9],
    ["V", 5],
    ["IV", 4],
    ["I", 1],
  ]);

  let roman = "";
  // 从大到小遍历map
  for (const [symbol, number] of map) {
    // 不断减去当前罗马数字对应的整数，直到num小于当前整数
    while (num >= number) {
      num -= number;
      // 拼接对应的罗马数字
      roman += symbol;
    }
  }
  return roman;
}
```

### 19.最后一个单词的长度

给你一个字符串`s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

```js
function lengthOfLastWord(s) {
  // 去除尾部的空格
  s = s.trimRight();
  // 从后向前找到第一个空格
  const idx = s.lastIndexOf(" ");

  return s.length - idx - 1;
}

// 另一种解法：不用数组方法
function lengthOfLastWord(s) {
  let index = s.length - 1;
  // 从后向前遍历，记录第一个非空格的位置(相当于去除右侧空格)
  while (s[index] === ' ') {
    index--;
  }
  let wordLength = 0;
  // 继续向前遍历
  while (index >= 0 && s[index] !== ' ') {
    // 每次遇到非空格就+1，记录最后一个单词长度
    wordLength++;
    index--;
  }
  return wordLength;
};
```

### 20.最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串`""`。

```js
function longestCommonPrefix(strs) {
  if (strs.length === 1) return strs[0]  
  let min = 0, max = 0
  
  // 找出数组中的最大值及最小值字符串
  // 最小字符串与最大字符串的最长公共前缀也为其他字符串的公共前缀，即为字符串数组的最长公共前缀
  // 例如ab、abc、ac，最大的是ac，最小的ab
  // ab和ac的最长公共前缀是a
  for (let i = 1; i < strs.length; i++) {
    if (strs[min] > strs[i]) {
      min = i
    }
    if (strs[max] < strs[i]) {
      max = i
    }
  }
  // 遍历最小字符串，找出公共前缀
  for (let j = 0; j < strs[min].length; j++) {
    if (strs[min].charAt(j) !== strs[max].charAt(j)) {
      return strs[min].substring(0, j)
    }
  }
  return strs[min]
};
```

### 21.反转字符串中的单词

给你一个字符串`s`，请你反转字符串中单词的顺序。

单词 是由非空格字符组成的字符串。`s`中使用至少一个空格将字符串中的 单词 分隔开。

返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。

注意：输入字符串`s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

```js
function reverseWords(s) {
  // 去除首尾空格
  s = s.trim();

  // 以空格为分隔符，将字符串分割成数组
  // 例如s = "the sky is blue"，words = ["the","sky","is","blue"]
  const words = s.split(" ");
  let res = "";

  // 从后向前遍历单词列表，依次将单词拼接至res
  for (let i = words.length - 1; i >= 0; i--) {
    // 遇到空格则跳过
    if (words[i] === "") continue;
    res += words[i];
    if (i !== 0) res += " ";
  }

  return res;
}

// 另一种解法：双指针
function reverseWords(s) {
  // 删除首尾空格
  s = s.trim();
  let j = s.length - 1,
    i = j;
  let res = "";
  while (i >= 0) {
    // 搜索首个空格
    // 例如s = "the sky is blue", s.length = 15, i = 14, j = 14
    // 找到第一个空格时，i = 10, j = 14，此时s.substring(i + 1, j + 1) = "blue"
    while (i >= 0 && s[i] !== " ") i--;
    // 添加单词
    res += s.substring(i + 1, j + 1) + " ";

    // 找到下一个单词的尾部，将j指向下一个单词的尾部，继续循环
    while (i >= 0 && s[i] === " ") i--;
    j = i;
  }
  return res.trimRight();
}
```

### 22.N 字形变换

将一个给定字符串`s`根据给定的行数`numRows`，以从上往下、从左到右进行`Z`字形排列。

比如输入字符串为`"PAYPALISHIRING"`行数为`3`时，排列如下：

`P   A   H   N
A P L S I I G
Y   I   R`

之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

```js
function convert(s, numRows) {
  // 边界条件
  if (numRows < 2) return s;
  const res = new Array(numRows).fill("");

  let i = 0,
    flag = -1;
  for (const c of s) {
    // 把每个字符 c 填入对应行 res[i]
    // 例如s = "LEETCODEISHIRING" numRows = 4 时：
    // res[0] = "L", flag = 1, i = 1
    // res[1] = "E", flag不变, i = 2
    // res[2] = "E", flag不边, i = 3
    // res[3] = "T", flag = -1, i = 2
    // res[2] = "C", flag不变, i = 1
    // ...
    res[i] += c;

    // 转折点为头和尾，即为0和numRows-1
    // 在达到 ZZZ 字形转折点时，执行反向
    if (i === 0 || i === numRows - 1) flag = -flag;

    // 更新当前字符对应的行索引
    i += flag;
  }
  return res.join("");
}
```


### 23.找出字符串中第一个匹配项的下标

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。


```js
function strStr(haystack, needle) {
  if (needle === '') return 0
  if (haystack === '' || haystack.length < needle.length) return -1

  return haystack.indexOf(needle)
};
```

### 24.文本左右对齐

给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。

你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。

要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。

文本的最后一行应为左对齐，且单词之间不插入额外的空格。

注意:

单词是指由非空格字符组成的字符序列。
每个单词的长度大于 0，小于等于 maxWidth。
输入单词数组 words 至少包含一个单词。

```js
todo
```

## 双指针


### 25.验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串`s`，如果它是 回文串 ，返回`true`；否则，返回`false`


```js
// 左右指针，一个指向头，一个指向尾
function isPalindrome(s: string) {
  let l = 0,
    r = s.length - 1;
  const reg = /^[a-zA-Z0-9]$/;
  while (l < r) {
    // 依次比较，相等就把两个指针都移一位
    if (s[l].toLowerCase() === s[r].toLowerCase()) {
      l++;
      r--;
    // 非字母数字，就把指针移一位
    } else if (!reg.test(s[l])) {
      l++;
    } else if (!reg.test(s[r])) {
      r--;
    // 不等则不满足条件
    } else {
      return false;
    }
  }

  return true;
}
```

### 26.判断子序列

给定字符串`s`和`t`，判断`s`是否为`t`的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

```js
// 双指针，分别指向两个字符的初始位置
function isSubsequence(s, t) {
  let i = 0, j = 0
  
  // 因为是判断短串在长串中是否匹配，所以短串走完了就说明能匹配上
  while(i < s.length && j < t.length) {
    // 如果指向的字符相同，短串指针移动一位
    if (s[i] === t[j]) {
      i++
    } 
    j++
  }
  return i === s.length
}

// 另一种解法：动态规划todo
```

### 27.两数之和 II - 输入有序数组

给你一个下标从`1`开始的整数数组`numbers`，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 `target`的两个数。如果设这两个数分别是`numbers[index1]`和`numbers[index2]`，则`1 <= index1 < index2 <= numbers.length`。

以长度为`2`的整数数组`[index1, index2]`的形式返回这两个整数的下标`index1`和`index2`。

你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。

你所设计的解决方案必须只使用常量级的额外空间。

```js
// 左右指针，一个指向头，一个指向尾
function twoSum(numbers, target) {
  let l = 0,  r = numbers.length - 1

  // 因为numbers是递增排列的，所以如果指针指向的两个元素之和大于目标值
  // 则尾部指针向前移动一位（越往前元素越小，小于目标值，则头部指针向后移动一位（越往后元素越大
  while (l < r) {
    if (numbers[l] + numbers[r] > target) {
      r--
    } else if (numbers[l] + numbers[r] < target) {
      l++
    } else {
      return [l + 1, r + 1]
    }
  }
};
```

### 28.盛最多水的容器

给定一个长度为`n`的整数数组`height`。有`n`条垂线，第`i`条线的两个端点是`(i, 0)`和`(i, height[i])`。

找出其中的两条线，使得它们与`x`轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。

```js
// 贪心
function maxArea (ht) {
  // 初始化 i, j分列容器两端
  let i = 0
  let j = ht.length - 1
  // 初始最大容量为 0
  let res = 0
  while (i < j) {
    // 计算容量，容量等于高度乘以宽度，其中高度由短板决定，宽度是两隔板的索引之差
    const cap = Math.min(ht[i], ht[j]) * (j - i)
    res = Math.max(res, cap)
    // 判断那边是短板，然后向内移动短板
    // 因为是找最大容量，只有向内收缩短板，才有可能使容量变大（虽然宽度变短，但是高度可能变大）
    if (ht[i] > ht[j]) {
      j--
    } else {
      i++
    }
  }
  return res
}
```

### 29.三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

你返回所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

```js
todo
```

## 滑动窗口

### 30.长度最小的子数组

```js
function minSubArrayLen(target, nums) {
  // l，r维护一个滑动窗口
  let l = 0,
    r = 0,
    // 记录窗口内值的和
    sum = 0,
    // 记录最小窗口长度
    min = Infinity;

  while (r < nums.length) {
    sum += nums[r];

    // 当窗口内值的和大于等于target时，就找到了一个满足条件的子数组
    while (sum >= target) {
      // 记录长度
      min = Math.min(r - l + 1, min);
      // 移动左指针，缩小窗口
      sum -= nums[l];
      l++;
    }
    r++;
  }

  return min === Infinity ? 0 : min;
}
```


### 31.无重复字符的最长子串

给定一个字符串`s` ，请你找出其中不含有重复字符的 最长子串 的长度。

```ts
// 用字符串（也可以换成数组）维护一个滑动窗口
function lengthOfLongestSubstring(s: string) {
  let max = 0;
  let str = "";
  for (let i = 0; i < s.length; i++) {
    // 判断这个窗口中是否存在这个字符
    const idx = str.indexOf(s[i]);

    if (idx === -1) {
      // 不存在则扩大窗口
      str += s[i];
      // 更新窗口的最大值
      max = Math.max(max, str.length);
    } else {
      // 存在则移动窗口
      // abc => abca => bca
      str = str.substr(idx + 1) + s[i];
    }
  }
  return max;
}

// 另一种思路
// 双指针维护滑动窗口
function lengthOfLongestSubstring(s: string) {
  let max = 0;
  for (let i = 0, j = 0; j < s.length; j++) {
    // 判断这个窗口中是否存在s[j]
    const idx = s.substring(i, j).indexOf(s[j]);
    // 如果存在，则缩小窗口
    if (idx !== -1) {
      i = i + idx + 1;
    }
    // 更新窗口最大值
    max = Math.max(max, j - i + 1);
  }
  return max;
}
```

### 32.串联所有单词的子串

```js
todo
```


### 33.最小覆盖子串

```js
todo
```


## 矩阵

### 34.有效的数独


请你判断一个`9 x 9`的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字`1-9`在每一行只能出现一次。
数字`1-9`在每一列只能出现一次。
数字`1-9`在每一个以粗实线分隔的`3x3`宫内只能出现一次。（请参考示例图）
 

注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
空白格用 '.' 表示。

```js


```

### 35.螺旋矩阵

```js
todo
```

### 36.旋转图像


```js

```

### 37.矩阵置零

```js

```

### 38.生命游戏

```js

```

## 哈希表

### 39.赎金信

给你两个字符串：`ransomNote`和`magazine`，判断`ransomNote`能不能由`magazine`里面的字符构成。

如果可以，返回`true`；否则返回`false`。

`magazine`中的每个字符只能在`ransomNote`中使用一次。

```js
// 字符统计
function canConstruct(ransomNote, magazine) {
  // 边界条件
  if (ransomNote.length > magazine.length) {
    return false;
  }

  // 用一个map存储ransomNote中字符的出现次数（也可以存magazine中字符的出现次数）
  const map = new Map();

  // 例如 ransomNote = "aab",  map = {a:2, b:1}
  for (const str of ransomNote) {
    map.set(str, (map.get(str) || 0) + 1);
  }

  // 遍历magazine，如果map中存在该字符，则将其次数减1
  for (const str of magazine) {
    if (map.has(str)) {
      const count = map.get(str) - 1;
      // 如果次数为0，则删除该字符
      if (count === 0) {
        map.delete(str);
      } else {
        map.set(str, count);
      }
    }

    // 如果map为空，则说明ransomNote中的字符都在magazine中出现过
    if (map.size === 0) {
      return true;
    }
  }

  return false;
}
```

### 40.同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```js
const isIsomorphic = function (s, t) {
  if (s.length !== t.length) {
    return false;
  }
  const sMap = new Map();
  const tMap = new Map();

  for (let i = 0; i < s.length; i++) {
    const a = s[i];
    const b = t[i];

    if (
      (sMap.has(a) && sMap.get(a) !== b) ||
      (tMap.has(b) && tMap.get(b) !== a)
    )
      return false;

    sMap.set(a, b);

    tMap.set(b, a);
  }

  return true;
};


// 同构字符串，每个字符 首次出现、最后出现、指定位出现 索引始终相同
function isIsomorphic(s, t) {
  // 边界条件，长度不同，直接返回false
  if (s.length !== t.length) {
    return false;
  }
  // 例如 s = "foo", t = "bar", i = 2
  // s.indexOf(s[2]) = 1, t.indexOf(t[2]) = 2，s和t不同构
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
      return false;
    }
  }
  return true;
}
```

### 41.单词规律

给定一种规律`pattern`和一个字符串`s`，判断`s`是否遵循相同的规律。

这里的 遵循 指完全匹配，例如，`pattern`里的每个字母和字符串`s`中的每个非空单词之间存在着双向连接的对应规律。

```js
// 双哈希存映射关系
function wordPattern(pattern, s) {
  const mapS = new Map();
  const mapPattern = new Map();

  const arr = s.split(" ");

  // 边界条件处理
  if (pattern.length !== arr.length) return false;

  for (let i = 0; i < arr.length; i++) {
    // 比较映射关系
    // 例如pattern = 'abba', s = 'dog dog dog dog', arr = ['dog', 'dog', 'dog', 'dog']
    // 第一次遍历时，mapS.set('dog', 'a'), mapPattern('a', 'dog')
    // 第二次遍历，mapS.get('dog') = a, pattern[1] = 'b', a !== b
    if (
      (mapPattern.has(pattern[i]) && mapPattern.get(pattern[i]) !== arr[i]) ||
      (mapS.has(arr[i]) && mapS.get(arr[i]) !== pattern[i])
    ) {
      return false;
    }

    // 相互存映射关系
    mapS.set(arr[i], pattern[i]);
    mapPattern.set(pattern[i], arr[i]);
  }

  return true;
}
```

### 42.有效的字母异位词

给定两个字符串`s`和`t`，编写一个函数来判断`t`是否是`s`的字母异位词。

注意：若`s`和`t`中每个字符出现的次数都相同，则称`s`和`t`互为字母异位词。

```js
function isAnagram(s, t) {
  // 边界条件
  if (s.length !== t.length) return false;
  // 哈希记录每个字符出现的次数
  const map = new Map();

  // 遍历s记录
  for (const c of s) {
    map.set(c, (map.get(c) || 0) + 1);
  }

  // 遍历t
  for (const c of t) {
    // 获取当前字符数量
    const count = map.get(c);

    // 减1后，如果为0，则删除这个字符记录
    if (count === 1) map.delete(c);
    else map.set(c, count - 1);
  }

  // 判断map是否为空，即所有字符记录都被删除
  return map.size === 0;
}
```

### 43.字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的所有字母得到的一个新单词。


```ts
function groupAnagrams(strs: string[]): string[][] {
  const map = new Map<string, string[]>();
  for (const str of strs) {
    // 把遍历到的字符串按照字母顺序排序
    const k = str.split("").sort().toString();

    // 作为map的key，ate, eat, tea 排序后都是aet，即相同的key
    const list = map.get(k) || [];
    list.push(str);
    map.set(k, list);
  }

  // Array.from 从可迭代或类数组对象创建一个新的浅拷贝的数组实例
  return Array.from(map.values());
}
```

### 44.两数之和

给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出 和为目标值`target`的那两个整数，并返回它们的数组下标。

```ts
// 暴力枚举
function twoSum(nums: number[], target: number) {
  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];

    for (let j = i + 1; j < nums.length; j++) {
      if (el + nums[j] === target) {
        return [i, j];
      }
    }
  }
}


// 另一种解法：哈希
function twoSum(nums: number[], target: number) {
  // 用 map 存储遍历过的元素和对应的索引
  const map = new Map<number, number>()

  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];
    // 每遍历一个元素，看看 map 中是否存在满足要求的目标数字
    if (map.has(target - el)) {
      return [map.get(target - el), i];
    }
    
    map.set(el, i)
  }
}
```

### 45.快乐数

编写一个算法来判断一个数`n`是不是快乐数。

「快乐数」 定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为`1`，也可能是 无限循环 但始终变不到`1`。
如果这个过程 结果为`1，那么这个数就是快乐数。
如果`n`是 快乐数 就返回`true`；不是，则返回`false`。

```js
// 通过题意

function getNext(n) {
  // 把这个数每个位置上的数都平方一下，然后相加，得到下一个数
  return String(n).split("").map(item => item**2).reduce((acc,cur)=> acc+cur)
}

// 快慢指针
function isHappy(n) {
  let slow = n
  // 有可能第一步就判断出是快乐数
  let fast = getNext(n)

  // 由于这个数有可能无限循环始终变不到1（因此得出这个数的所有可能结果构成一个环
  while(fast !== 1) {
    // 慢指针每次走1步
    slow = getNext(slow)
    // 快指针每次走2步
    fast = getNext(getNext(fast))
    // 如果相交则有环
    if (slow === fast) {
      return false
    }
  }

  return true
};

// 另一种解法：哈希
// 思路也是判断是否存在重复结果
function isHappy(n) {
  const set = new Set()

  while (n !== 1) {
    if (set.has(n)) {
      return false
    }
    set.add(n)
    n = getNext(n)
  }

  return true
};
```


### 46.存在重复元素 II

给你一个整数数组`nums`和一个整数`k`，判断数组中是否存在两个 不同的索引`i`和`j`，满足`nums[i] == nums[j]`且`abs(i - j) <= k`。如果存在，返回`true`；否则，返回`false`。

```js
function containsNearbyDuplicate(nums, k) {
  // 哈希存每次遍历元素及对应索引
  const map = new Map();
  for (let i = 0; i < nums.length; i++) {
    // 当遍历到重复元素时，判断两个索引是否满足条件
    if (map.has(nums[i]) && i - map.get(nums[i]) <= k) return true;
    map.set(nums[i], i);
  }
  return false;
}


// 另一种解法：滑动窗口
function containsNearbyDuplicate(nums, k) {
  // 维护一个哈希表，里面始终最多包含 k 个元素
  const set = new Set();
  for (let i = 0; i < nums.length; i++) {
    // 当出现重复值时则说明在 k 距离内存在重复元素
    if (set.has(nums[i])) {
      return true;
    }
    set.add(nums[i]);
    // 每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 k，则移除最前面的数字
    if (set.size > k) {
      set.delete(nums[i - k]);
    }
  }
  return false;
}
```


### 47.最长连续序列

给定一个未排序的整数数组`nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

```ts
function longestConsecutive(nums: Number[]): number {
  if (nums.length === 0) return 0;
  // 从小到大排序
  nums.sort((a, b) => a - b);
  let max = 1;

  // 每次连续的计数
  let count = 1;

  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];
    // 相邻两项相同，跳过
    if (el === nums[i + 1]) continue;
    // 连续项 计数+1
    if (el + 1 === nums[i + 1]) {
      count++;

      // 中断，将count与max比较，取最大值
    } else {
      max = Math.max(count, max);

      count = 1;
    }
  }

  return max;
}
```

## 区间

### 48.汇总区间

给定一个  无重复元素 的 有序 整数数组`nums`。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说`nums`的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于`nums`的数字`x`。

列表中的每个区间范围`[a,b]`应该按如下格式输出：

`"a->b"`，如果`a != b`
`"a"`，如果`a == b`


```js
function summaryRanges(nums) {
  const len = nums.length;
  const ans = [];
  let i = 0;
  while (i < len) {
    let j = i;

    // 找到从 i 开始连续的最后一位
    while (j + 1 < len && nums[j] + 1 === nums[j + 1]) j++;

    // 拼接区间
    if (j === i) ans.push(`${nums[i]}`);
    else ans.push(`${nums[i]}->${nums[j]}`);

    i = j + 1;
  }
  return ans;
}
```

### 49.合并区间

以数组`intervals`表示若干个区间的集合，其中单个区间为`intervals[i] = [starti, endi]`。
请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。

```js
function merge(intervals) {
  // 边界条件
  if (intervals.length < 2) {
    return intervals;
  }
  const res = [];
  // 根据区间首位大小排序
  intervals.sort((a, b) => a[0] - b[0]);

  // 初始为第一个区间
  let prev = intervals[0];

  for (let i = 1; i < intervals.length; i++) {
    // 当前的区间
    const cur = intervals[i];
    // 有重合, 扩大区间
    // 例如 intervals = [[1, 3],[2, 6]]，prev = [1, 3]，cur = [2, 6]
    // prev[1] = 3，cur[0] = 2，有重合，更新prev = [1, 6]
    if (prev[1] >= cur[0]) {
      prev[1] = Math.max(cur[1], prev[1]);
    } else {
      // 不重合，prev推入res数组
      res.push(prev);
      // 更新 prev
      prev = cur;
    }
  }

  res.push(prev);
  return res;
}
```

### 50.插入区间

给你一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

```js
function insert(intervals, newInterval) {
  // 边界条件
  if (intervals.length === 0) {
    return [newInterval];
  }
  const res = [];
  // 遍历区间，判断当前区间和插入区间是否有重合，如果没有重合则直接插入，有重合则合并区间
  let i = 0,
    [start, end] = newInterval,
    len = intervals.length;

  // 左边的不重叠区间
  while (i < len && start > intervals[i][1]) {
    res.push(intervals[i]);
    i++;
  }

  // 重叠区间
  while (i < len && end >= intervals[i][0]) {
    start = Math.min(start, intervals[i][0]);
    end = Math.max(end, intervals[i][1]);
    i++;
  }

  res.push([start, end]);

  // 右边的不重叠区间
  while (i < len) {
    res.push(intervals[i]);
    i++;
  }

  return res;
}
```

### 51.用最少数量的箭引爆气球

有一些球形气球贴在一堵用`XY`平面表示的墙面上。墙面上的气球记录在整数数组`points`，其中`points[i] = [xstart, xend]`表示水平直径在`xstart`和`xend`之间的气球。你不知道气球的确切`y`坐标。

一支弓箭可以沿着`x`轴从不同点 完全垂直 地射出。在坐标`x`处射出一支箭，若有一个气球的直径的开始和结束坐标为`xstart，xend`且满足`xstart ≤ x ≤ xend`，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组`points`，返回引爆所有气球所必须射出的 最小 弓箭数 。

```js

```

## 栈

### 52.有效的括号

给定一个只包括`'('，')'，'{'，'}'，'['，']'`的字符串`s`，判断字符串是否有效。

有效字符串需满足：

1.左括号必须用相同类型的右括号闭合。
2.左括号必须以正确的顺序闭合。
3.每个右括号都有一个对应的相同类型的左括号。

```js
function isValid(s) {
  // 边界条件，奇数长度肯定不符合
  if (s.length % 2 === 1) return false;
  // 维护一个栈
  const stack = [];
  // 定义左括号和右括号的对应关系
  const map = {
    "(": ")",
    "{": "}",
    "[": "]",
  };
  for (let i = 0; i < s.length; i++) {
    const char = s[i];

    if (map[char]) {
      // 如果是左括号，将其推入栈
      stack.push(char);
    } else {
      // 如果是右括号，检查是否与栈顶的左括号匹配
      const top = stack.pop();

      if (char !== map[top]) {
        return false; // 不匹配则字符串无效
      }
    }
  }

  // 最后，栈应该为空，如果不为空，说明有未闭合的括号
  return stack.length === 0;
}
```

### 53.简化路径

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。

```js
function simplifyPath(path) {
  const stack = [];
  // 以/做切割，例如path = '/home//foo/'，切割后为['', 'home', '', 'foo', '']
  path = path.split("/");

  for (const s of path) {
    // 遇到..，弹出栈顶
    if (s === "..") {
      stack.pop();
    // 把当前目录压入栈中
    } else if (s !== "" && s !== ".") {
      stack.push(s);
    }
  }

  // 补齐分隔符/
  return "/" + stack.join("/");
}
```

### 54.最小栈

设计一个支持`push ，pop ，top`操作，并能在常数时间内检索到最小元素的栈。

实现`MinStack`类:

`MinStack()`初始化堆栈对象。
`void push(int val)`将元素val推入堆栈。
`void pop()`删除堆栈顶部的元素。
`int top()`获取堆栈顶部的元素。
`int getMin()`获取堆栈中的最小元素。


```js
// 辅助栈
const MinStack = function () {
  this.stack = [];
  // 维护一个辅助栈，始终保持栈顶元素为最小元素
  this.minStack = [];
};

MinStack.prototype.push = function (val) {
  this.stack.push(val);

  if (this.minStack.length === 0) {
    this.minStack.push(val);
  } else {
    // 每次入栈时，取出辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中
    this.minStack.push(Math.min(this.minStack[this.minStack.length - 1], val));
  }
};

// 当一个元素要出栈时，把辅助栈的栈顶元素也一并弹出；
MinStack.prototype.pop = function () {
  this.stack.pop();
  this.minStack.pop();
};

MinStack.prototype.top = function () {
  return this.stack[this.stack.length - 1];
};

MinStack.prototype.getMin = function () {
  return this.minStack[this.minStack.length - 1];
};


// 另一种思路：不用额外空间
function MinStack() {
  // 存储要入栈的值与当前最小值的差
  this.stack = [];
  this.min = 0;
}

MinStack.prototype.push = function (val) {
  // 当栈空时，直接将最小值设置为要入栈的值，并将将0入栈。
  if (this.stack.length === 0) {
    this.stack.push(0);
    this.min = val;
  } else {
    // 当栈非空时，计算要入栈的值与当前最小值的差
    // 例如第一次push 2，第二次push 1, diff = -1
    // stack = [2, -1], min = 1
    // 此时top，diff < 0，min不变
    // 此时pop，diff < 0, 更新min = 2
    const diff = val - this.min;
    this.stack.push(diff);
    // 若差为负数则说明要入栈的值小于当前最小值，则更新最小值，否则最小值不变，然后将差值入栈。
    if (diff < 0) {
      this.min = val;
    }
  }
};

MinStack.prototype.pop = function () {
  const diff = this.stack.pop();
  // 当栈顶元素为正值时，说明入栈元素比最小值大，最小值不用更新
  // 当栈顶元素为负值时，说明入栈元素比最小值小，最小值=原始值-差值
  if (diff < 0) {
    this.min -= diff;
  }
};

MinStack.prototype.top = function () {
  const diff = this.stack[this.stack.length - 1];
  // 当栈顶元素为负值时，说明最小值就是栈顶原始元素
  if (diff < 0) {
    return this.min;
  }
  // 当栈顶元素为正值时，原始元素=差值+最小值
  // 例如，第一次push 1, 第二次push 2, diff = 1, min = 1
  // top = min + diff
  return this.min + diff;
};

MinStack.prototype.getMin = function () {
  return this.min;
};
```

### 55.逆波兰表达式求值

给你一个字符串数组`tokens`，表示一个根据 逆波兰表示法 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

注意：

- 有效的算符为`'+'、'-'、'*' 和 '/'`。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 向零截断 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 32 位 整数表示。

```js
function evalRPN(tokens) {
  const s = new Map([
    // +number -> 转为数值类型
    ["+", (a, b) => +a + +b],
    ["-", (a, b) => b - a],
    ["*", (a, b) => b * a],
    // number | 0 -> 取整
    ["/", (a, b) => (b / a) | 0],
  ]);
  // 维护一个栈
  const stack = [];
  for (const i of tokens) {
    // 判断i是否是操作符
    if (!s.has(i)) {
      // 如果遇到数字就进栈
      stack.push(i);
      continue;
    }
    // 如果遇到操作符，就从栈顶弹出两个数字运算
    stack.push(s.get(i)(stack.pop(), stack.pop()));
  }
  // 返回结果
  return stack.pop();
}
```


### 56.基本计算器

给你一个字符串表达式`s`，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如`eval()`。

```js
todo
```

### 57.环形链表

给你一个链表的头节点`head`，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪`next`指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数`pos`来表示链表尾连接到链表中的位置（索引从`0`开始）。注意`pos`不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回`true`。 否则，返回`false`。

```js
// 标记法
function hasCycle(head) {
  while (head) {
    // 给节点打标记，如果下次循环中碰到有标记的节点
    // 证明链表有环
    if (head.tag) {
      return true;
    }

    head.tag = true;
    head = head.next;
  }

  return false;
}


// 另一种解法：双(快慢)指针
function hasCycle(head) {
  // 快、慢指针，从头节点出发
  let p1 = head;
  let p2 = head;

  // 循环的出口是快指针走到链表尾
  while (p2 && p2.next) {
    // 慢指针每次走一步
    p1 = p1.next;
    // 快指针每次走两步
    p2 = p2.next.next;
    // 如果两个指针指向的节点相等，则链表有环
    if (p1 === p2) {
      return true;
    }
  }
  return false;
}
```

### 58. 两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。


```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

function addTwoNumbers(l1, l2) {
  // 虚拟头结点
  const dummy = new ListNode();
  let cur = dummy;
  let n = 0;

  // 存在l1和l2链表长度不一致的情况
  // 当一个链表的节点直到尾部后，就只用处理另一个链表
  while (l1 || l2) {
    let sum = 0;
    // 把l1和l2的节点逐位相加
    if (l1) {
      sum += l1.val;
      // 加完后指向下一个节点
      l1 = l1.next;
    }

    if (l2) {
      sum += l2.val;
      l2 = l2.next;
    }

    sum += n;
    // 如果相加大于等于10，需要进一位
    n = sum >= 10 ? 1 : 0;
    cur.next = new ListNode(sum % 10);
    // 指向下一个节点
    cur = cur.next;
  }

  // 最后两个节点相加也存在大于等于10的情况
  if (n) {
    cur.next = new ListNode(n);
  }

  return dummy.next;
}
```

### 59.合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

function mergeTwoLists(list1, list2) {
  // 虚拟头节点
  const dummy = new ListNode();
  let cur = dummy;

  // 合并两个链表
  while (list1 && list2) {
    // 判断节点的大小关系
    if (list1.val < list2.val) {
      cur.next = new ListNode(list1.val);
      list1 = list1.next;
    } else {
      cur.next = new ListNode(list2.val);
      list2 = list2.next;
    }
    // 指向下一个节点
    cur = cur.next;
  }
  // 循环后，存在两种情况，链表list1长度大于list2
  // 此时只需将cur的下一个节点指向list1
  if (list1) {
    cur.next = list1;
  }

  if (list2) {
    cur.next = list2;
  }

  return dummy.next;
}


// 另一种解法：递归
function mergeTwoLists(l1, l2) {
  // 节点为空，链表l1走完了
  if (l1 == null) {
    return l2;
  } else if (l2 == null) {
    return l1;

  // 下面是l1和l2节点都不为空的情况
  } else if (l1.val < l2.val) {
    // 递归地合并链表l1的下一个节点和链表l2
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}
```

### 60.复制带随机指针的链表

给你一个长度为`n`的链表，每个节点包含一个额外增加的随机指针`random`，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由`n`个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的`next`指针和`random`指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

```js
function Node(val, next, random) {
  this.val = val;
  this.next = next;
  this.random = random;
}

function copyRandomList(head) {
  // 边界条件
  if (!head) return head;

  let cur = head;
  // 利用hash表构建原链表节点 和 新链表对应节点 的键值对映射关系
  const map = new Map();

  // 第一次遍历，构建新链表
  while (cur) {
    map.set(cur, new Node(cur.val));
    cur = cur.next;
  }
  // 指回头节点，第二次遍历
  cur = head;
  while (cur) {
    map.get(cur).next = map.get(cur.next) || null;
    map.get(cur).random = map.get(cur.random) || null;
    cur = cur.next;
  }
  return map.get(head);
}
```

### 61.反转链表II

给你单链表的头指针`head`和两个整数`left`和`right`，其中`left <= right`。请你反转从位置`left`到位置`right`的链表节点，返回 反转后的链表 。


```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

function reverseBetween(head, left, right) {
  // 边界条件
  if (left === right) {
    return head;
  }
  //虚拟头节点
  const dummy = new ListNode();
  dummy.next = head;
  let pre = dummy;
  for (let i = 0; i < left - 1; i++) {
    //pre前进到left的前一个节点
    pre = pre.next;
  }

  // left位置对应的节点
  const cur = pre.next;
  for (let i = 0; i < right - left; i++) {
    //循环right - left次 反转中间的节点
    const next = cur.next;
    cur.next = next.next;

    next.next = pre.next;
    pre.next = next;
  }

  //返回虚拟头节点的next
  return dummy.next;
}
```

### 62.K 个一组翻转链表

```js
todo
```

### 63.删除链表的倒数第 N 个节点

给你一个链表，删除链表的倒数第`n`个结点，并且返回链表的头结点。

```js
// 删除倒数第N个节点
// 1.找到倒数第N个节点
// 2.删除这个节点 = 把这个节点的前一个节点指向这个节点的下一个节点
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

// 快慢指针找倒数第N个节点，先让快指针走N步，然后快慢指针一起走
// 当快指针走到最后时，此时的慢指针就是倒数第N个节点
function removeNthFromEnd(head, n) {
  const dummy = new ListNode(0, head);
  let slow = dummy;
  let fast = dummy;

  // fast 向后移动 n 个位置
  while (n-- > 0) fast = fast.next;

  // fast 走到最后，slow 此时是 倒数第 n 个元素的前一个
  while (fast && fast.next) {
    fast = fast.next;
    slow = slow.next;
  }

  // slow 的下一个节点就是要删除的节点
  slow.next = slow.next.next;

  return dummy.next;
}
```

### 64.删除排序链表中的重复元素 II

给定一个已排序的链表的头`head`， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。

```js
function ListNode(val, next) {
  this.val = val === undefined ? 0 : val;
  this.next = next === undefined ? null : next;
}

function deleteDuplicates(head) {
  // 虚拟头节点
  const dummy = new ListNode(0, head);

  // 快慢指针，slow.next = fast
  let slow = dummy;
  let fast = dummy.next;

  while (fast) {
    // fast如果遇到重复的就一直向后走，直到遇到非重复
    // 此时fast指向的节点就是重复节点
    while (fast.next && fast.val === fast.next.val) fast = fast.next;

    // 如果慢指针和快指针相隔不为1位，则出现过重复
    if (slow.next !== fast) {
      // 删除重复节点
      slow.next = fast.next;
    } else {
      // 相隔为1位
      slow = slow.next;
    }

    fast = fast.next;
  }

  return dummy.next;
}
```

### 65.旋转链表

给你一个链表的头节点`head`，旋转链表，将链表每个节点向右移动`k`个位置。

```js
// 闭合成环
function rotateRight (head, k) {
  // 边界条件处理
  if (!head || !head.next || k === 0) {
    return head
  }

  let size = 1
  let cur = head
  // 找到原链表的最后一个节点，并统计链表长度
  while (cur.next) {
    cur = cur.next
    size++
  }
  // 更新有效k值
  k = k % size
  // 若更新后等于0，则无需移动链表
  if (k === 0) {
    return head
  }
  // 将其与原链表的头结点相连（成环）
  let move = size - k
  cur.next = head

  // 找到截断位置
  while (move > 0) {
    cur = cur.next
    move--
  }
  const ans = cur.next
  // 截断链表
  cur.next = null

  return ans
};


// 另一种解法：快慢指针
function rotateRight(head, k) {
  // 边界条件
  if (head === null || !head.next || k === 0) return head

  let size = 1
  let cur = head
  // 计算链表的长度，并找到最后一个节点
  while (cur.next) {
    cur = cur.next
    size += 1
  }
  // 计算有效的 k 值：对于与链表长度成整数倍的「旋转」都是没有意义的（旋转前后链表不变）
  k %= size
  if (k === 0) return head

  // 使用「快慢指针」找到倒数第 k 个节点（新头结点）：slow 会停在「新头结点」的「前一位」，也就是「新尾结点」
  let slow = head
  let fast = head
  while (k-- > 0) fast = fast.next
  // 循环结束后，slow指向倒数第k个节点的前一个节点
  // fast指向最后一个节点
  while (fast.next) {
    slow = slow.next
    fast = fast.next
  }

  // 保存新头结点，并将新尾结点的 next 指针置空
  const ans = slow.next
  slow.next = null

  // 将新链表的前半部分（原链表的后半部分）与原链表的头结点链接上
  fast.next = head
  return ans
}
```

### 66.分隔链表

给你一个链表的头节点`head`和一个特定值`x`，请你对链表进行分隔，使得所有 小于`x`的节点都出现在 大于或等于`x`的节点之前。

你应当 保留 两个分区中每个节点的初始相对位置。

```js
function ListNode (val, next) {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}

function partition (head, x) {
  if (!head || !head.next) {
    return head
  }
  // 新建两个链表，list1保存链表head中小于x的
  const list1 = new ListNode()
  // list2保存链表head中大于x的
  const list2 = new ListNode()

  let l1 = list1
  let l2 = list2
  // 遍历原链表
  while (head) {
    // 比较节点与x的大小
    if (head.val < x) {
      l1.next = head
      l1 = l1.next
    } else {
      l2.next = head
      l2 = l2.next
    }
    head = head.next
  }
  // 拼接两链表
  l1.next = list2.next
  l2.next = null

  return list1.next
};
```

### 67.LRU缓存

`Least Recently Used`最近最少使用，算法根据数据的历史记录来进行淘汰数据，其核心思想“如果数据最近被访问过，那么将来被访问的几率也更高”。

```js
class LRUCache {
  cache = new Map();
  constructor(max) {
    this.max = max
  }

  put(key, val) {
    if (this.cache.has(key)) {
      this.cache.delete(key)
    }
    this.cache.set(key, val)

    if (this.cache.size > this.max) {
      // Map原型上的keys方法会返回一个引用的迭代器对象，包含按顺序插入的每个元素的key值
      const delKey = this.cache.keys().next().value
      this.cache.delete(delKey)
    }
  }

  get(key)  {
    if (this.cache.has(key)) {
      const val = this.cache.get(key)
      this.cache.delete(key)
      this.put(key, val)
      return val
    }

    return null
  }
}
```

### 68.二叉树的最大深度

给定一个二叉树`root`，返回其最大深度。

二叉树的最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。

```js
// 数的最大深度 = 根节点的高度（即1）+ 左右子树的最大深度中的较大者
// DFS(深度优先遍历)解法
function maxDepth (root) {
  if (!root) return 0
  // 递归获取左右子树的最大深度
  const left = maxDepth(root.left)
  const right = maxDepth(root.right)

  // 取出左右子树的最大深度中的较大者
  return 1 + Math.max(left, right)
}


// BFS(广度优先遍历)解法
function maxDepth (root) {
  if (root == null) return 0
  const queue = [root]

  let depth = 1

  while (queue.length) {
    // 获取当前层的节点数
    let size = queue.length
    // 逐个让当前层的节点出列
    while (size--) {
      const cur = queue.shift()
      // 当前节点如果还有子节点就入列
      if (cur.left) queue.push(cur.left)
      if (cur.right) queue.push(cur.right)
    }
    // 当前层所有节点已经出列，如果队列不为空，说明有下一层节点，depth+1
    if (queue.length) depth++
  }

  return depth
}
```

### 69.相同的树

给你两棵二叉树的根节点`p`和`q`，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

```js
// DFS
function isSameTree (p, q) {
  if (!p && !q) return true

  // 递归判断每个子节点是否相等
  if (p && q && p.val === q.val &&
  isSameTree(p.left, q.left) &&
  isSameTree(p.right, q.right)
  ) {
    return true
  }
  return false
}


// BFS
function isSameTree (p, q) {
  const pQueue = [p]
  const qQueue = [q]
  while (pQueue.length) {
    const nodeP = pQueue.pop()
    const nodeQ = qQueue.pop()
    // 判断空节点
    if (!nodeP || !nodeQ) {
      // 一个节点为空，一个不为空
      if (nodeP !== nodeQ) return false
      // 两个都为空直接跳出本次循环
      continue
    }

    // 节点值不同
    if (nodeP.val !== nodeQ.val) return false
    // 依次添加子节点，有可能为null
    pQueue.push(nodeP.left)
    pQueue.push(nodeP.right)
    qQueue.push(nodeQ.left)
    qQueue.push(nodeQ.right)
  }
  return true
}
```

### 70.翻转二叉树

给你一棵二叉树的根节点`root`，翻转这棵二叉树，并返回其根节点。

```js
// DFS
function invertTree (root) {
  // 终止条件：当前节点为 null 时返回
  if (root === null) return null

  const tmp = root.left
  // 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点
  root.left = invertTree(root.right)
  root.right = invertTree(tmp)
  return root
}


// BFS
function invertTree (root) {
  if (root == null) {
    return null
  }
  // 维护一个队列，初始推入第一层的root
  const queue = [root]

  while (queue.length) {
    const cur = queue.shift()
    // 交换当前节点的左右节点
    const tmp = cur.left
    cur.left = cur.right
    cur.right = tmp

    if (cur.left) {
      queue.push(cur.left)
    }
    if (cur.right) {
      queue.push(cur.right)
    }
  }
  return root
}
```

### 71.对称二叉树

给你一个二叉树的根节点`root`， 检查它是否轴对称。

```js
// DFS
function isSymmetric (root) {
  if (root === null) {
    return true
  }
  const check = (l, r) => {
    // 两个子节点都不存在
    if (!l && !r) {
      return true
    }
    // 两个子节点都存在
    if (l && r) {
      return l.val === r.val && check(l.left, r.right) && check(l.right, r.left)
    }
    // 一个子树存在一个不存在，不对称
    return false
  }

  // 判断左右子树是否满足对称
  return check(root.left, root.right)
}


// BFS
function isSymmetric (root) {
  if (!root) return true
  // 维护两个栈，依次将左右子树推入栈种
  const leftStack = []; const rightStack = []
  let curLeft = root.left // 当前的左子树
  let curRight = root.right // 当前的右子树

  while (curLeft || curRight || leftStack.length || rightStack.length) {
    // 左子树存在, 不断将左子树入栈
    while (curLeft) {
      leftStack.push(curLeft)
      curLeft = curLeft.left
    }
    // 右子树存在, 不断将右子树入栈
    while (curRight) {
      rightStack.push(curRight)
      curRight = curRight.right
    }
    // 栈的高度不相等，说明结构不对称
    if (leftStack.length !== rightStack.length) return false
    // 取出栈顶节点
    curLeft = leftStack.pop()
    curRight = rightStack.pop()
    // 两个栈出栈的节点值不相等 不对称
    if (curLeft.val !== curRight.val) return false
    // 交换左右子树比较
    curLeft = curLeft.right
    curRight = curRight.left
  }
  return true
}
```

### 72.从前序与中序遍历序列构造二叉树

给定两个整数数组`preorder`和`inorder`，其中`preorder`是二叉树的先序遍历，`inorder`是同一棵树的中序遍历，请构造二叉树并返回其根节点。

```js
function buildTree (preorder, inorder) {
  // 当preorder和inorder均为空的时候说明已经到了空节点
  if (!preorder.length || !inorder.length) return null

  // 一开始前序遍历数组的首位对应树的根节点的值
  // 创建根节点 -> preorder[0]
  const node = new TreeNode(preorder[0])

  // 找到这个节点对应中序遍历数组中的位置，以这个位置为分界点
  // 左侧子数组对应这个节点的左子树，右侧同理
  const index = inorder.indexOf(preorder.shift())

  // 左右子树递归
  node.left = buildTree(preorder, inorder.slice(0, index))
  node.right = buildTree(preorder, inorder.slice(index + 1))

  // 返回根节点
  return node
}
```

### 73.从中序与后序遍历序列构造二叉树

给定两个整数数组`inorder`和`postorder`，其中`inorder`是二叉树的中序遍历，`postorder`是同一棵树的后序遍历，请你构造并返回这颗二叉树。

```js
function buildTree (inorder, postorder) {
  if (!postorder.length) return null
  // 后序遍历最后一位为根节点的值
  const node = new TreeNode(postorder[postorder.length - 1])

  // 找到这个节点对应中序遍历数组中的位置，以这个位置为分界点
  // 左侧子数组对应这个节点的左子树，右侧同理
  const index = inorder.indexOf(postorder.pop())

  // 递归左右子树
  node.left = buildTree(inorder.slice(0, index), postorder.slice(0, index))
  node.right = buildTree(inorder.slice(index + 1), postorder.slice(index))
  return node
}
```

### 74.填充每个节点的下一个右侧节点指针 II

给定一个二叉树：

```txt
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个`next`指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将`next`指针设置为`NULL`。

初始状态下，所有`next`指针都被设置为`NULL`。

```js
function connect (root) {
  if (root === null) {
    return root
  }
  // 维护一个队列，将根节点入队
  const queue = [root]

  // 当队列不为空则继续遍历
  while (queue.length) {
    // 记录这一层的节点数量
    let size = queue.length
    // 遍历当前层级的所有节点
    while (size-- > 0) {
      // 如果当前队列不为空证明有右节点
      // 则将其next指向右节点
      const node = queue.shift()
      if (size > 0)node.next = queue[0]

      // 将该节点的左右子节点入队
      if (node.left) {
        queue.push(node.left)
      }

      if (node.right) {
        queue.push(node.right)
      }
    }
  }
  return root
}
```

### 75.二叉树展开为链表

给你二叉树的根结点`root`，请你将它展开为一个单链表：

展开后的单链表应该同样使用`TreeNode`，其中`right`子指针指向链表中下一个结点，而左子指针始终为`null`。
展开后的单链表应该与二叉树 先序遍历 顺序相同。
 
 ```js
function flatten (root) {
  if (root == null) return

  flatten(root.left)
  flatten(root.right)

  // 1.先用两个变量把原先的左右子树保存起来
  const left = root.left
  const right = root.right

  // 2.将左子树作为右子树
  root.left = null
  root.right = left

  // 3.将原先的右子树接到当前右子树的末端
  while (root.right != null) {
    root = root.right
  }
  root.right = right
};
 ```

 ### 76.路径总和

 给你二叉树的根节点`root`和一个表示目标和的整数`targetSum`。判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和`targetSum`。如果存在，返回`true`；否则，返回`false`。

叶子节点 是指没有子节点的节点。

```js
function hasPathSum (hasPathSumroot, sum) {
  // 根节点为空
  if (root === null) return false

  // 没有左右子节点了，即路径走到头了
  if (root.left === null && root.right === null) return root.val === sum

  // 减去当前节点的值，并递归
  sum = sum - root.val
  // 递归左右子节点
  return hasPathSum(root.left, sum) || hasPathSum(root.right, sum)
}
```

### 77.求根节点到叶节点数字之和

给你一个二叉树的根节点`root`，树中每个节点都存放有一个`0`到`9`之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径`1 -> 2 -> 3`表示数字`123`。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

```js

```