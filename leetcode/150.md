
[LeetCode 150](https://leetcode.cn/studyplan/top-interview-150/)

## 数组/字符串
### 1.合并两个有序数组

给你两个按 非递减顺序 排列的整数数组`nums1`和`nums2`，另有两个整数`m`和`n`，分别表示`nums1`和`nums2`中的元素数目。

请你 合并`nums2`到`nums1`中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组`nums1`中。为了应对这种情况，`nums1`的初始长度为`m + n`，其中前`m`个元素表示应合并的元素，后`n`个元素为 0 ，应忽略。`nums2` 的长度为`n`


```ts
// 逆向双指针
function merge(nums1: number[], m: number, nums2: number[], n: number): void {
  let i = nums1.length - 1
  m--
  n--
  // 结束条件为第二个数组全部插入进去
  while (n >= 0) {
    // 比较两个数组，选择一个最大的塞到nums1的尾部
    // 比较一次后，前进一位
    if (nums1[m] > nums2[n]) {
      nums1[i--] = nums1[m--]
    } else {
      nums1[i--] = nums2[n--]
    }
  }
};
```


### 2.移除元素

给你一个数组`nums`和一个值` val`，你需要 原地 移除所有数值等于`val`的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```ts
// 拷贝覆盖
function removeElement(nums: number[], val: number): number {
  // 记录移除后数组的新长度
  let count = 0
  for (const num of nums) {
    // 遍历过程中如果出现数字与需要移除的值不相同时覆盖
    // 记录+1
    if (num !== val) {
      nums[count] = val
      count++
    }
  }
  return count
};
```

### 3.删除有序数组中的重复项

给你一个 升序排列 的数组`nums`，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回`nums`中唯一元素的个数。

```ts
// 数组是有序的，重复元素肯定相邻
function removeDuplicates(nums: number[]): number {
  // 快慢指针，第一个指针i指向第一个数，第二个指针j指向第二个数
  let i = 0;
  for (let j = 1; j < nums.length; j++) {
    // 如果不相等，则把指针i向右移1位，然后覆盖重复元素
    if (nums[i] !== nums[j]) {
      i++
      // 例如 nums = [1, 1, 2], i = 0, j = 1
      // 第一次循环：nums[i] = 1, nums[j] = 1，相等，j++
      // 第二次循环: nums[i] = 1, nums[j] = 2, 不相等，i++, nums[i] = nums[j]，把重复的1改为2
      nums[i] = nums[j]
    }
  }
  // 索引是从0开始，长度要+1
  return i + 1
};
```

### 4.删除有序数组中的重复项 II

给你一个有序数组`nums`，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。


```ts
// 计数法，每个元素最多重复两次
function removeDuplicates(nums) {
  if (nums.length <= 2) return nums.length;
  let i = 0;
  // 记录重复元素
  let count = 0;
  for (let j = 1; j < nums.length; j++) {
    // 重复元素，计数+1
    if (nums[i] === nums[j]) {
      count++;
      // 不重复了，计数清零
    } else count = 0;

    // 计数小于2，说明重复元素不超过2个，可以继续添加
    if (count < 2) {
      i++;
      nums[i] = nums[j];
    }
  }
  return i + 1;
}
```

### 5.多数元素

给定一个大小为`n`的数组`nums`，返回其中的多数元素。多数元素是指在数组中出现次数 大于`⌊ n/2 ⌋`的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

```js
function majorityElement(nums) {
  // 排序数组，
  nums.sort((a, b) => a - b);
  // 如果有一个元素出现次数大于n/2，则在数组nums.length/2的位置就是这个数
  return nums[Math.floor(nums.length / 2)];
}


// 另一种解法：哈希
function majorityElement(nums) {
  const map = new Map()
  for (const num of nums) {
    // 存储每个元素出现的次数
    map.set(num, (map.get(num) || 0) + 1)

    // 判断出现次数是否大于数组长度/2
    if (map.get(num) > nums.length / 2) {
        return num
    }
  }
}
```

### 6.旋转数组

给定一个整数数组`nums`，将数组中的元素向右轮转`k`个位置，其中`k`是非负数。

```js
// 把数组向右旋转k个位置，就是当前索引位置加k
// 如果直接i + k的话，前k个索引位置就没有元素了，因此需要 i + k % nums.length
// i + k < nums.length时，就是i + k的位置，而此时i + k % nums.length，还是i + k
// i + k > nums.length时，就是i + k % nums.length的位置
function rotate(nums, k) {
  // 使用另一个数组依次存储旋转位置后的每个元素
  const newArr = []
  const len = nums.length
  for (let i = 0; i < len; i++) {
    // 例如，nums = [1, 2, 3, 4], k = 2
    // 当i = 0时，(0 + 2) % 4 = 2, 此时newArr[2] = nums[i]
    // 1被移动到了原先3的位置
    // 当i = 1时，(1 + 2) % 4 = 3, 2被移动到了4的位置
    // 以此类推...
    newArr[(i + k) % len] = nums[i]
  }

  // 再将新数组依次拷贝到原数组
  for (let i = 0; i < len; i++) {
    nums[i] = newArr[i]
  }
}

// 另一种解法：数组翻转
const reverse = (nums, l, r) => {
  while(l < r) {
    const temp = nums[l]
    nums[l] = nums[r]
    nums[r] = temp
    l++
    r--
  }
}

function rotate(nums, k) {
  // 例如nums = [1, 2, 3, 4], k = 2
  k = k % nums.length
  // 先翻转整个数组 -> [4, 3, 2, 1]
  reverse(nums, 0, nums.length - 1)
  // 再翻转0到k - 1区间 -> [3, 4, 2, 1]
  reverse(nums, 0, k - 1)
  // 最后翻转k到数组长度减1的区间 -> [3, 4, 1, 2]
  reverse(nums, k, nums.length - 1)
};
```

### 7. 买卖股票的最佳时机

给定一个数组`prices`，它的第`i`个元素`prices[i]`表示一支给定股票第`i`天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回`0`。


```js
// 贪心算法，取最左最小值，取最右最大值，差值即为最大利润
function maxProfit(prices) {
  // 边界条件
  if (prices.length === 0) return 0;
  // 最低买点
  let min = prices[0];
  // 最大收入
  let max = 0;

  for (let i = 1; i < prices.length; i++) {
    // 更新最低买点
    min = Math.min(min, prices[i]);
    // 更新最大利润
    max = Math.max(max, prices[i] - min);
  }

  return max;
};

// 动态规划
// 定义状态，i表示天数，0：不持有股票，1：持有股票
// 第i天不持有，由第i-1天不持有然后不操作 和 第i-1天持有然后卖出，两种情况的最大值
// dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])

// 第i天持有 由 第i-1天持有然后不操作 和 第i-1天不持有然后买入 两种情况的最大值
// dp[i][1] = Math.max(dp[i - 1][1], -prices[i])

// 最大收益为：dp[n - 1][0]而不是dp[n - 1][1]
// 最后一天不持有比持有更高
function maxProfit (prices) {
  const len = prices.length;
  const dp = Array.from(new Array(n), () => new Array(2));
  dp[0][0] = 0; // 第0天不持有
  dp[0][1] = -prices[0]; // 第0天持有
  for (let i = 1; i < len; i++) {
    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
  }
  return dp[n - 1][0];
};
```




## 双指针


### 验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串`s`，如果它是 回文串 ，返回`true`；否则，返回`false`


```js
// 思路: 左右指针，一个指向头，一个指向尾
function isPalindrome(s: string) {
  let i = 0,
    j = s.length - 1;
  const reg = /^[a-zA-Z0-9]$/;
  while (i < j) {
    // 依次比较，相等就把两个指针都移一位
    if (s[i].toLowerCase() === s[j].toLowerCase()) {
      i++;
      j--;
    // 非字母数字，就把指针移一位
    } else if (!reg.test(s[i])) {
      i++;
    } else if (!reg.test(s[j])) {
      j--;
    // 不等则不满足条件
    } else {
      return false;
    }
  }

  return true;
}
```

## 滑动窗口

### 长度最小的子数组

```js
function minSubArrayLen(target, nums) {
  // l，r维护一个滑动窗口
  let l = 0,
    r = 0,
    // 记录窗口内值的和
    sum = 0,
    // 记录最小窗口长度
    min = Infinity;

  while (r < nums.length) {
    sum += nums[r];

    // 当窗口内值的和大于等于target时，就找到了一个满足条件的子数组
    while (sum >= target) {
      // 记录长度
      min = Math.min(r - l + 1, min);
      // 移动左指针，缩小窗口
      sum -= nums[l];
      l++;
    }
    r++;
  }

  return min === Infinity ? 0 : min;
}
```


### 无重复字符的最长子串

给定一个字符串`s` ，请你找出其中不含有重复字符的 最长子串 的长度。

```ts
// 用字符串（也可以换成数组）维护一个滑动窗口
function lengthOfLongestSubstring(s: string) {
  let max = 0;
  let str = "";
  for (let i = 0; i < s.length; i++) {
    // 判断这个窗口中是否存在这个字符
    const idx = str.indexOf(s[i]);

    if (idx === -1) {
      // 不存在则扩大窗口
      str += s[i];
      // 更新窗口的最大值
      max = Math.max(max, str.length);
    } else {
      // 存在则移动窗口
      // abc => abca => bca
      str = str.substr(idx + 1) + s[i];
    }
  }
  return max;
}

// 另一种思路
// 双指针维护滑动窗口
function lengthOfLongestSubstring(s: string) {
  let max = 0;
  for (let i = 0, j = 0; j < s.length; j++) {
    // 判断这个窗口中是否存在s[j]
    const idx = s.substring(i, j).indexOf(s[j]);
    // 如果存在，则缩小窗口
    if (idx !== -1) {
      i = i + idx + 1;
    }
    // 更新窗口最大值
    max = Math.max(max, j - i + 1);
  }
  return max;
}
```





## 哈希表

### 赎金信

给你两个字符串：`ransomNote`和`magazine`，判断`ransomNote`能不能由`magazine`里面的字符构成。

如果可以，返回`true`；否则返回`false`。

`magazine`中的每个字符只能在`ransomNote`中使用一次。

```js
// 字符统计
function canConstruct(ransomNote, magazine) {
  // 边界条件
  if (ransomNote.length > magazine.length) {
    return false;
  }

  // 用一个map存储ransomNote中字符的出现次数（也可以存magazine中字符的出现次数）
  const map = new Map();

  // 例如 ransomNote = "aab",  map = {a:2, b:1}
  for (const str of ransomNote) {
    map.set(str, (map.get(str) || 0) + 1);
  }

  // 遍历magazine，如果map中存在该字符，则将其次数减1
  for (const str of magazine) {
    if (map.has(str)) {
      const count = map.get(str) - 1;
      // 如果次数为0，则删除该字符
      if (count === 0) {
        map.delete(str);
      } else {
        map.set(str, count);
      }
    }

    // 如果map为空，则说明ransomNote中的字符都在magazine中出现过
    if (map.size === 0) {
      return true;
    }
  }

  return false;
}
```

### 同构字符串

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

```js
const isIsomorphic = function (s, t) {
  if (s.length !== t.length) {
    return false;
  }
  const sMap = new Map();
  const tMap = new Map();

  for (let i = 0; i < s.length; i++) {
    const a = s[i];
    const b = t[i];

    if (
      (sMap.has(a) && sMap.get(a) !== b) ||
      (tMap.has(b) && tMap.get(b) !== a)
    )
      return false;

    sMap.set(a, b);

    tMap.set(b, a);
  }

  return true;
};


// 同构字符串，每个字符 首次出现、最后出现、指定位出现 索引始终相同
function isIsomorphic(s, t) {
  // 边界条件，长度不同，直接返回false
  if (s.length !== t.length) {
    return false;
  }
  // 例如 s = "foo", t = "bar", i = 2
  // s.indexOf(s[2]) = 1, t.indexOf(t[2]) = 2，s和t不同构
  for (let i = 0; i < s.length; i++) {
    if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
      return false;
    }
  }
  return true;
}
```

### 两数之和

给定一个整数数组`nums`和一个整数目标值`target`，请你在该数组中找出 和为目标值`target`的那两个整数，并返回它们的数组下标。

```ts
// 暴力枚举
function twoSum(nums: number[], target: number) {
  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];

    for (let j = i + 1; j < nums.length; j++) {
      if (el + nums[j] === target) {
        return [i, j];
      }
    }
  }
}


// 哈希
function twoSum(nums: number[], target: number) {
  // 用 map 存储遍历过的元素和对应的索引
  const map = new Map<number, number>()

  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];
    // 每遍历一个元素，看看 map 中是否存在满足要求的目标数字
    if (map.has(target - el)) {
      return [map.get(target - el), i];
    }
    
    map.set(el, i)
  }
}
```

### 字母异位词分组

给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词 是由重新排列源单词的所有字母得到的一个新单词。


```ts
function groupAnagrams(strs: string[]): string[][] {
  const map = new Map<string, string[]>();
  for (const str of strs) {
    // 把遍历到的字符串按照字母顺序排序
    const k = str.split("").sort().toString();

    // 作为map的key，ate, eat, tea 排序后都是aet，即相同的key
    const list = map.get(k) || [];
    list.push(str);
    map.set(k, list);
  }

  // Array.from 从可迭代或类数组对象创建一个新的浅拷贝的数组实例
  return Array.from(map.values());
}
```

### 最长连续序列

给定一个未排序的整数数组`nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

```ts
function longestConsecutive(nums: Number[]): number {
  if (nums.length === 0) return 0;
  // 从小到大排序
  nums.sort((a, b) => a - b);
  let max = 1;

  // 每次连续的计数
  let count = 1;

  for (let i = 0; i < nums.length; i++) {
    const el = nums[i];
    // 相邻两项相同，跳过
    if (el === nums[i + 1]) continue;
    // 连续项 计数+1
    if (el + 1 === nums[i + 1]) {
      count++;

      // 中断，将count与max比较，取最大值
    } else {
      max = Math.max(count, max);

      count = 1;
    }
  }

  return max;
}
```