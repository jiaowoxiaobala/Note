遍历数组

```ts
// string[][number] -> string
// [1, 2, 3][number] -> 1 | 2 | 3
type MapArr<T extends unknown> = T[number]
```

遍历对象的方式构建数组

```ts
// 当T为数组类型时 { [K in keyof T]: T[K] } 会构建一个数组类型
type MapArrayKey<T extends unknown[]> = {
  [K in keyof T]: T[K]
}
```


分布式条件类型

```ts
// 条件类型左边如果是联合类型，会触发分布式条件类型,
// T<1 | 2> -> T<1> | T<2>
// 可以通过自己extends自己触发
type Distributive<U> = U extends U ? [U] : never

// [1] | [2] | [3]
type Test = Distributive<1 | 2 | 3> 
```

解构元组的联合类型时，也有分布式条件类型的效果

```ts
type TupleUnion = [2, 3] | [4, 5]

// [1, ...[2, 3]] | [1, ...[4, 5]]
type Test = [1, ...TupleUnion]
```

`length`属性

```ts
type Tuple = [1, 2, 3]

// 元组的length是元组具体的长度（数字字面量类型
type TupleLen = tuple['length'] // 3

type Array = number[]

// 数组的length是number类型
type ArrayLen = Array['length'] // number


// 字符串的length也是number类型
type stringLen = '123'['length'] // number

// 如何读取字符串的length为真实的长度 - 构建数组

type ReadStrLen<S extends string, CountArr extends unknown[] = []> = S extends `${infer F}${infer Rest}` ? ReadStrLen<Rest, [...CountArr, F]> : CountArr['length']
```